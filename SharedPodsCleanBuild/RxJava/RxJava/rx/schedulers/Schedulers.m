//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/kgalligan/devel/xp/RxJava/src/main/java/rx/schedulers/Schedulers.java
//

#include "J2ObjC_source.h"
#include "java/util/concurrent/Executor.h"
#include "rx/Scheduler.h"
#include "rx/plugins/RxJavaPlugins.h"
#include "rx/plugins/RxJavaSchedulersHook.h"
#include "rx/schedulers/CachedThreadScheduler.h"
#include "rx/schedulers/EventLoopsScheduler.h"
#include "rx/schedulers/ExecutorScheduler.h"
#include "rx/schedulers/ImmediateScheduler.h"
#include "rx/schedulers/NewThreadScheduler.h"
#include "rx/schedulers/Schedulers.h"
#include "rx/schedulers/TestScheduler.h"
#include "rx/schedulers/TrampolineScheduler.h"

@interface RxSchedulersSchedulers () {
 @public
  RxScheduler *computationScheduler_;
  RxScheduler *ioScheduler_;
  RxScheduler *newThreadScheduler_;
}

- (instancetype)init;

@end

J2OBJC_FIELD_SETTER(RxSchedulersSchedulers, computationScheduler_, RxScheduler *)
J2OBJC_FIELD_SETTER(RxSchedulersSchedulers, ioScheduler_, RxScheduler *)
J2OBJC_FIELD_SETTER(RxSchedulersSchedulers, newThreadScheduler_, RxScheduler *)

inline RxSchedulersSchedulers *RxSchedulersSchedulers_get_INSTANCE();
static RxSchedulersSchedulers *RxSchedulersSchedulers_INSTANCE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(RxSchedulersSchedulers, INSTANCE, RxSchedulersSchedulers *)

__attribute__((unused)) static void RxSchedulersSchedulers_init(RxSchedulersSchedulers *self);

__attribute__((unused)) static RxSchedulersSchedulers *new_RxSchedulersSchedulers_init() NS_RETURNS_RETAINED;

__attribute__((unused)) static RxSchedulersSchedulers *create_RxSchedulersSchedulers_init();

J2OBJC_INITIALIZED_DEFN(RxSchedulersSchedulers)

@implementation RxSchedulersSchedulers

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  RxSchedulersSchedulers_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (RxScheduler *)immediate {
  return RxSchedulersSchedulers_immediate();
}

+ (RxScheduler *)trampoline {
  return RxSchedulersSchedulers_trampoline();
}

+ (RxScheduler *)newThread {
  return RxSchedulersSchedulers_newThread();
}

+ (RxScheduler *)computation {
  return RxSchedulersSchedulers_computation();
}

+ (RxScheduler *)io {
  return RxSchedulersSchedulers_io();
}

+ (RxSchedulersTestScheduler *)test {
  return RxSchedulersSchedulers_test();
}

+ (RxScheduler *)fromWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)executor {
  return RxSchedulersSchedulers_fromWithJavaUtilConcurrentExecutor_(executor);
}

+ (void)initialize {
  if (self == [RxSchedulersSchedulers class]) {
    RxSchedulersSchedulers_INSTANCE = new_RxSchedulersSchedulers_init();
    J2OBJC_SET_INITIALIZED(RxSchedulersSchedulers)
  }
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "Schedulers", NULL, 0x2, NULL, NULL },
    { "immediate", NULL, "Lrx.Scheduler;", 0x9, NULL, NULL },
    { "trampoline", NULL, "Lrx.Scheduler;", 0x9, NULL, NULL },
    { "newThread", NULL, "Lrx.Scheduler;", 0x9, NULL, NULL },
    { "computation", NULL, "Lrx.Scheduler;", 0x9, NULL, NULL },
    { "io", NULL, "Lrx.Scheduler;", 0x9, NULL, NULL },
    { "test", NULL, "Lrx.schedulers.TestScheduler;", 0x9, NULL, NULL },
    { "fromWithJavaUtilConcurrentExecutor:", "from", "Lrx.Scheduler;", 0x9, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "computationScheduler_", NULL, 0x12, "Lrx.Scheduler;", NULL, NULL, .constantValue.asLong = 0 },
    { "ioScheduler_", NULL, 0x12, "Lrx.Scheduler;", NULL, NULL, .constantValue.asLong = 0 },
    { "newThreadScheduler_", NULL, 0x12, "Lrx.Scheduler;", NULL, NULL, .constantValue.asLong = 0 },
    { "INSTANCE", "INSTANCE", 0x1a, "Lrx.schedulers.Schedulers;", &RxSchedulersSchedulers_INSTANCE, NULL, .constantValue.asLong = 0 },
  };
  static const J2ObjcClassInfo _RxSchedulersSchedulers = { 2, "Schedulers", "rx.schedulers", NULL, 0x11, 8, methods, 4, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_RxSchedulersSchedulers;
}

@end

void RxSchedulersSchedulers_init(RxSchedulersSchedulers *self) {
  NSObject_init(self);
  RxScheduler *c = [((RxPluginsRxJavaSchedulersHook *) nil_chk([((RxPluginsRxJavaPlugins *) nil_chk(RxPluginsRxJavaPlugins_getInstance())) getSchedulersHook])) getComputationScheduler];
  if (c != nil) {
    self->computationScheduler_ = c;
  }
  else {
    self->computationScheduler_ = new_RxSchedulersEventLoopsScheduler_init();
  }
  RxScheduler *io = [((RxPluginsRxJavaSchedulersHook *) nil_chk([((RxPluginsRxJavaPlugins *) nil_chk(RxPluginsRxJavaPlugins_getInstance())) getSchedulersHook])) getIOScheduler];
  if (io != nil) {
    self->ioScheduler_ = io;
  }
  else {
    self->ioScheduler_ = new_RxSchedulersCachedThreadScheduler_init();
  }
  RxScheduler *nt = [((RxPluginsRxJavaSchedulersHook *) nil_chk([((RxPluginsRxJavaPlugins *) nil_chk(RxPluginsRxJavaPlugins_getInstance())) getSchedulersHook])) getNewThreadScheduler];
  if (nt != nil) {
    self->newThreadScheduler_ = nt;
  }
  else {
    self->newThreadScheduler_ = RxSchedulersNewThreadScheduler_instance();
  }
}

RxSchedulersSchedulers *new_RxSchedulersSchedulers_init() {
  RxSchedulersSchedulers *self = [RxSchedulersSchedulers alloc];
  RxSchedulersSchedulers_init(self);
  return self;
}

RxSchedulersSchedulers *create_RxSchedulersSchedulers_init() {
  return new_RxSchedulersSchedulers_init();
}

RxScheduler *RxSchedulersSchedulers_immediate() {
  RxSchedulersSchedulers_initialize();
  return RxSchedulersImmediateScheduler_instance();
}

RxScheduler *RxSchedulersSchedulers_trampoline() {
  RxSchedulersSchedulers_initialize();
  return RxSchedulersTrampolineScheduler_instance();
}

RxScheduler *RxSchedulersSchedulers_newThread() {
  RxSchedulersSchedulers_initialize();
  return ((RxSchedulersSchedulers *) nil_chk(RxSchedulersSchedulers_INSTANCE))->newThreadScheduler_;
}

RxScheduler *RxSchedulersSchedulers_computation() {
  RxSchedulersSchedulers_initialize();
  return ((RxSchedulersSchedulers *) nil_chk(RxSchedulersSchedulers_INSTANCE))->computationScheduler_;
}

RxScheduler *RxSchedulersSchedulers_io() {
  RxSchedulersSchedulers_initialize();
  return ((RxSchedulersSchedulers *) nil_chk(RxSchedulersSchedulers_INSTANCE))->ioScheduler_;
}

RxSchedulersTestScheduler *RxSchedulersSchedulers_test() {
  RxSchedulersSchedulers_initialize();
  return new_RxSchedulersTestScheduler_init();
}

RxScheduler *RxSchedulersSchedulers_fromWithJavaUtilConcurrentExecutor_(id<JavaUtilConcurrentExecutor> executor) {
  RxSchedulersSchedulers_initialize();
  return new_RxSchedulersExecutorScheduler_initWithJavaUtilConcurrentExecutor_(executor);
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(RxSchedulersSchedulers)
