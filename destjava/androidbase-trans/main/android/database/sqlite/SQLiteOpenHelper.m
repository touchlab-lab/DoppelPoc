//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/kgalligan/devel/xp/androidbase/AndroidBase/lib/src/main/java/android/database/sqlite/SQLiteOpenHelper.java
//

#include "IOSClass.h"
#include "J2ObjC_source.h"
#include "android/content/Context.h"
#include "android/database/DatabaseErrorHandler.h"
#include "android/database/sqlite/SQLiteDatabase.h"
#include "android/database/sqlite/SQLiteException.h"
#include "android/database/sqlite/SQLiteOpenHelper.h"
#include "android/util/Log.h"
#include "java/io/File.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"

@interface AndroidDatabaseSqliteSQLiteOpenHelper () {
 @public
  AndroidContentContext *mContext_;
  NSString *mName_;
  id<AndroidDatabaseSqliteSQLiteDatabase_CursorFactory> mFactory_;
  jint mNewVersion_;
  AndroidDatabaseSqliteSQLiteDatabase *mDatabase_;
  jboolean mIsInitializing_;
  jboolean mEnableWriteAheadLogging_;
  id<AndroidDatabaseDatabaseErrorHandler> mErrorHandler_;
}

- (AndroidDatabaseSqliteSQLiteDatabase *)getDatabaseLockedWithBoolean:(jboolean)writable;

@end

J2OBJC_FIELD_SETTER(AndroidDatabaseSqliteSQLiteOpenHelper, mContext_, AndroidContentContext *)
J2OBJC_FIELD_SETTER(AndroidDatabaseSqliteSQLiteOpenHelper, mName_, NSString *)
J2OBJC_FIELD_SETTER(AndroidDatabaseSqliteSQLiteOpenHelper, mFactory_, id<AndroidDatabaseSqliteSQLiteDatabase_CursorFactory>)
J2OBJC_FIELD_SETTER(AndroidDatabaseSqliteSQLiteOpenHelper, mDatabase_, AndroidDatabaseSqliteSQLiteDatabase *)
J2OBJC_FIELD_SETTER(AndroidDatabaseSqliteSQLiteOpenHelper, mErrorHandler_, id<AndroidDatabaseDatabaseErrorHandler>)

inline NSString *AndroidDatabaseSqliteSQLiteOpenHelper_get_TAG();
static NSString *AndroidDatabaseSqliteSQLiteOpenHelper_TAG;
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidDatabaseSqliteSQLiteOpenHelper, TAG, NSString *)

inline jboolean AndroidDatabaseSqliteSQLiteOpenHelper_get_DEBUG_STRICT_READONLY();
#define AndroidDatabaseSqliteSQLiteOpenHelper_DEBUG_STRICT_READONLY false
J2OBJC_STATIC_FIELD_CONSTANT(AndroidDatabaseSqliteSQLiteOpenHelper, DEBUG_STRICT_READONLY, jboolean)

__attribute__((unused)) static AndroidDatabaseSqliteSQLiteDatabase *AndroidDatabaseSqliteSQLiteOpenHelper_getDatabaseLockedWithBoolean_(AndroidDatabaseSqliteSQLiteOpenHelper *self, jboolean writable);

J2OBJC_INITIALIZED_DEFN(AndroidDatabaseSqliteSQLiteOpenHelper)

@implementation AndroidDatabaseSqliteSQLiteOpenHelper

- (instancetype)initWithAndroidContentContext:(AndroidContentContext *)context
                                 withNSString:(NSString *)name
withAndroidDatabaseSqliteSQLiteDatabase_CursorFactory:(id<AndroidDatabaseSqliteSQLiteDatabase_CursorFactory>)factory
                                      withInt:(jint)version_ {
  AndroidDatabaseSqliteSQLiteOpenHelper_initWithAndroidContentContext_withNSString_withAndroidDatabaseSqliteSQLiteDatabase_CursorFactory_withInt_(self, context, name, factory, version_);
  return self;
}

- (instancetype)initWithAndroidContentContext:(AndroidContentContext *)context
                                 withNSString:(NSString *)name
withAndroidDatabaseSqliteSQLiteDatabase_CursorFactory:(id<AndroidDatabaseSqliteSQLiteDatabase_CursorFactory>)factory
                                      withInt:(jint)version_
      withAndroidDatabaseDatabaseErrorHandler:(id<AndroidDatabaseDatabaseErrorHandler>)errorHandler {
  AndroidDatabaseSqliteSQLiteOpenHelper_initWithAndroidContentContext_withNSString_withAndroidDatabaseSqliteSQLiteDatabase_CursorFactory_withInt_withAndroidDatabaseDatabaseErrorHandler_(self, context, name, factory, version_, errorHandler);
  return self;
}

- (NSString *)getDatabaseName {
  return mName_;
}

- (void)setWriteAheadLoggingEnabledWithBoolean:(jboolean)enabled {
  @synchronized(self) {
    if (mEnableWriteAheadLogging_ != enabled) {
      if (mDatabase_ != nil && [mDatabase_ isOpen] && ![mDatabase_ isReadOnly]) {
        if (enabled) {
          [mDatabase_ enableWriteAheadLogging];
        }
        else {
          [mDatabase_ disableWriteAheadLogging];
        }
      }
      mEnableWriteAheadLogging_ = enabled;
    }
  }
}

- (AndroidDatabaseSqliteSQLiteDatabase *)getWritableDatabase {
  @synchronized(self) {
    return AndroidDatabaseSqliteSQLiteOpenHelper_getDatabaseLockedWithBoolean_(self, true);
  }
}

- (AndroidDatabaseSqliteSQLiteDatabase *)getReadableDatabase {
  @synchronized(self) {
    return AndroidDatabaseSqliteSQLiteOpenHelper_getDatabaseLockedWithBoolean_(self, false);
  }
}

- (AndroidDatabaseSqliteSQLiteDatabase *)getDatabaseLockedWithBoolean:(jboolean)writable {
  return AndroidDatabaseSqliteSQLiteOpenHelper_getDatabaseLockedWithBoolean_(self, writable);
}

- (void)close {
  @synchronized(self) {
    if (mIsInitializing_) @throw new_JavaLangIllegalStateException_initWithNSString_(@"Closed during initialization");
    if (mDatabase_ != nil && [mDatabase_ isOpen]) {
      [mDatabase_ close];
      mDatabase_ = nil;
    }
  }
}

- (void)onConfigureWithAndroidDatabaseSqliteSQLiteDatabase:(AndroidDatabaseSqliteSQLiteDatabase *)db {
}

- (void)onCreateWithAndroidDatabaseSqliteSQLiteDatabase:(AndroidDatabaseSqliteSQLiteDatabase *)db {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)onUpgradeWithAndroidDatabaseSqliteSQLiteDatabase:(AndroidDatabaseSqliteSQLiteDatabase *)db
                                                 withInt:(jint)oldVersion
                                                 withInt:(jint)newVersion {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)onDowngradeWithAndroidDatabaseSqliteSQLiteDatabase:(AndroidDatabaseSqliteSQLiteDatabase *)db
                                                   withInt:(jint)oldVersion
                                                   withInt:(jint)newVersion {
  @throw new_AndroidDatabaseSqliteSQLiteException_initWithNSString_(JreStrcat("$I$I", @"Can't downgrade database from version ", oldVersion, @" to ", newVersion));
}

- (void)onOpenWithAndroidDatabaseSqliteSQLiteDatabase:(AndroidDatabaseSqliteSQLiteDatabase *)db {
}

+ (void)initialize {
  if (self == [AndroidDatabaseSqliteSQLiteOpenHelper class]) {
    AndroidDatabaseSqliteSQLiteOpenHelper_TAG = [AndroidDatabaseSqliteSQLiteOpenHelper_class_() getSimpleName];
    J2OBJC_SET_INITIALIZED(AndroidDatabaseSqliteSQLiteOpenHelper)
  }
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithAndroidContentContext:withNSString:withAndroidDatabaseSqliteSQLiteDatabase_CursorFactory:withInt:", "SQLiteOpenHelper", NULL, 0x1, NULL, NULL },
    { "initWithAndroidContentContext:withNSString:withAndroidDatabaseSqliteSQLiteDatabase_CursorFactory:withInt:withAndroidDatabaseDatabaseErrorHandler:", "SQLiteOpenHelper", NULL, 0x1, NULL, NULL },
    { "getDatabaseName", NULL, "Ljava.lang.String;", 0x1, NULL, NULL },
    { "setWriteAheadLoggingEnabledWithBoolean:", "setWriteAheadLoggingEnabled", "V", 0x1, NULL, NULL },
    { "getWritableDatabase", NULL, "Landroid.database.sqlite.SQLiteDatabase;", 0x1, NULL, NULL },
    { "getReadableDatabase", NULL, "Landroid.database.sqlite.SQLiteDatabase;", 0x1, NULL, NULL },
    { "getDatabaseLockedWithBoolean:", "getDatabaseLocked", "Landroid.database.sqlite.SQLiteDatabase;", 0x2, NULL, NULL },
    { "close", NULL, "V", 0x21, NULL, NULL },
    { "onConfigureWithAndroidDatabaseSqliteSQLiteDatabase:", "onConfigure", "V", 0x1, NULL, NULL },
    { "onCreateWithAndroidDatabaseSqliteSQLiteDatabase:", "onCreate", "V", 0x401, NULL, NULL },
    { "onUpgradeWithAndroidDatabaseSqliteSQLiteDatabase:withInt:withInt:", "onUpgrade", "V", 0x401, NULL, NULL },
    { "onDowngradeWithAndroidDatabaseSqliteSQLiteDatabase:withInt:withInt:", "onDowngrade", "V", 0x1, NULL, NULL },
    { "onOpenWithAndroidDatabaseSqliteSQLiteDatabase:", "onOpen", "V", 0x1, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "TAG", "TAG", 0x1a, "Ljava.lang.String;", &AndroidDatabaseSqliteSQLiteOpenHelper_TAG, NULL, .constantValue.asLong = 0 },
    { "DEBUG_STRICT_READONLY", "DEBUG_STRICT_READONLY", 0x1a, "Z", NULL, NULL, .constantValue.asBOOL = AndroidDatabaseSqliteSQLiteOpenHelper_DEBUG_STRICT_READONLY },
    { "mContext_", NULL, 0x12, "Landroid.content.Context;", NULL, NULL, .constantValue.asLong = 0 },
    { "mName_", NULL, 0x12, "Ljava.lang.String;", NULL, NULL, .constantValue.asLong = 0 },
    { "mFactory_", NULL, 0x12, "Landroid.database.sqlite.SQLiteDatabase$CursorFactory;", NULL, NULL, .constantValue.asLong = 0 },
    { "mNewVersion_", NULL, 0x12, "I", NULL, NULL, .constantValue.asLong = 0 },
    { "mDatabase_", NULL, 0x2, "Landroid.database.sqlite.SQLiteDatabase;", NULL, NULL, .constantValue.asLong = 0 },
    { "mIsInitializing_", NULL, 0x2, "Z", NULL, NULL, .constantValue.asLong = 0 },
    { "mEnableWriteAheadLogging_", NULL, 0x2, "Z", NULL, NULL, .constantValue.asLong = 0 },
    { "mErrorHandler_", NULL, 0x12, "Landroid.database.DatabaseErrorHandler;", NULL, NULL, .constantValue.asLong = 0 },
  };
  static const J2ObjcClassInfo _AndroidDatabaseSqliteSQLiteOpenHelper = { 2, "SQLiteOpenHelper", "android.database.sqlite", NULL, 0x401, 13, methods, 10, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_AndroidDatabaseSqliteSQLiteOpenHelper;
}

@end

void AndroidDatabaseSqliteSQLiteOpenHelper_initWithAndroidContentContext_withNSString_withAndroidDatabaseSqliteSQLiteDatabase_CursorFactory_withInt_(AndroidDatabaseSqliteSQLiteOpenHelper *self, AndroidContentContext *context, NSString *name, id<AndroidDatabaseSqliteSQLiteDatabase_CursorFactory> factory, jint version_) {
  AndroidDatabaseSqliteSQLiteOpenHelper_initWithAndroidContentContext_withNSString_withAndroidDatabaseSqliteSQLiteDatabase_CursorFactory_withInt_withAndroidDatabaseDatabaseErrorHandler_(self, context, name, factory, version_, nil);
}

void AndroidDatabaseSqliteSQLiteOpenHelper_initWithAndroidContentContext_withNSString_withAndroidDatabaseSqliteSQLiteDatabase_CursorFactory_withInt_withAndroidDatabaseDatabaseErrorHandler_(AndroidDatabaseSqliteSQLiteOpenHelper *self, AndroidContentContext *context, NSString *name, id<AndroidDatabaseSqliteSQLiteDatabase_CursorFactory> factory, jint version_, id<AndroidDatabaseDatabaseErrorHandler> errorHandler) {
  NSObject_init(self);
  if (version_ < 1) @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$I", @"Version must be >= 1, was ", version_));
  self->mContext_ = context;
  self->mName_ = name;
  self->mFactory_ = factory;
  self->mNewVersion_ = version_;
  self->mErrorHandler_ = errorHandler;
}

AndroidDatabaseSqliteSQLiteDatabase *AndroidDatabaseSqliteSQLiteOpenHelper_getDatabaseLockedWithBoolean_(AndroidDatabaseSqliteSQLiteOpenHelper *self, jboolean writable) {
  if (self->mDatabase_ != nil) {
    if (![self->mDatabase_ isOpen]) {
      self->mDatabase_ = nil;
    }
    else if (!writable || ![self->mDatabase_ isReadOnly]) {
      return self->mDatabase_;
    }
  }
  if (self->mIsInitializing_) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"getDatabase called recursively");
  }
  AndroidDatabaseSqliteSQLiteDatabase *db = self->mDatabase_;
  @try {
    self->mIsInitializing_ = true;
    if (db != nil) {
      if (writable && [db isReadOnly]) {
        [db reopenReadWrite];
      }
    }
    else if (self->mName_ == nil) {
      db = AndroidDatabaseSqliteSQLiteDatabase_createWithAndroidDatabaseSqliteSQLiteDatabase_CursorFactory_(nil);
    }
    else {
      @try {
        {
          db = [((AndroidContentContext *) nil_chk(self->mContext_)) openOrCreateDatabaseWithNSString:self->mName_ withInt:self->mEnableWriteAheadLogging_ ? AndroidContentContext_MODE_ENABLE_WRITE_AHEAD_LOGGING : 0 withAndroidDatabaseSqliteSQLiteDatabase_CursorFactory:self->mFactory_ withAndroidDatabaseDatabaseErrorHandler:self->mErrorHandler_];
        }
      }
      @catch (AndroidDatabaseSqliteSQLiteException *ex) {
        if (writable) {
          @throw ex;
        }
        AndroidUtilLog_eWithNSString_withNSString_withNSException_(AndroidDatabaseSqliteSQLiteOpenHelper_TAG, JreStrcat("$$$", @"Couldn't open ", self->mName_, @" for writing (will try read-only):"), ex);
        NSString *path = [((JavaIoFile *) nil_chk([((AndroidContentContext *) nil_chk(self->mContext_)) getDatabasePathWithNSString:self->mName_])) getPath];
        db = AndroidDatabaseSqliteSQLiteDatabase_openDatabaseWithNSString_withAndroidDatabaseSqliteSQLiteDatabase_CursorFactory_withInt_withAndroidDatabaseDatabaseErrorHandler_(path, self->mFactory_, AndroidDatabaseSqliteSQLiteDatabase_OPEN_READONLY, self->mErrorHandler_);
      }
    }
    [self onConfigureWithAndroidDatabaseSqliteSQLiteDatabase:db];
    jint version_ = [((AndroidDatabaseSqliteSQLiteDatabase *) nil_chk(db)) getVersion];
    if (version_ != self->mNewVersion_) {
      if ([db isReadOnly]) {
        @throw new_AndroidDatabaseSqliteSQLiteException_initWithNSString_(JreStrcat("$I$I$$", @"Can't upgrade read-only database from version ", [db getVersion], @" to ", self->mNewVersion_, @": ", self->mName_));
      }
      [db beginTransaction];
      @try {
        if (version_ == 0) {
          [self onCreateWithAndroidDatabaseSqliteSQLiteDatabase:db];
        }
        else {
          if (version_ > self->mNewVersion_) {
            [self onDowngradeWithAndroidDatabaseSqliteSQLiteDatabase:db withInt:version_ withInt:self->mNewVersion_];
          }
          else {
            [self onUpgradeWithAndroidDatabaseSqliteSQLiteDatabase:db withInt:version_ withInt:self->mNewVersion_];
          }
        }
        [db setVersionWithInt:self->mNewVersion_];
        [db setTransactionSuccessful];
      }
      @finally {
        [db endTransaction];
      }
    }
    [self onOpenWithAndroidDatabaseSqliteSQLiteDatabase:db];
    if ([db isReadOnly]) {
      AndroidUtilLog_wWithNSString_withNSString_(AndroidDatabaseSqliteSQLiteOpenHelper_TAG, JreStrcat("$$$", @"Opened ", self->mName_, @" in read-only mode"));
    }
    self->mDatabase_ = db;
    return db;
  }
  @finally {
    self->mIsInitializing_ = false;
    if (db != nil && db != self->mDatabase_) {
      [db close];
    }
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(AndroidDatabaseSqliteSQLiteOpenHelper)
