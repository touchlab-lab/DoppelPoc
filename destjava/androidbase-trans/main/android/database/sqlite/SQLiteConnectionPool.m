//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/kgalligan/devel/xp/androidbase/AndroidBase/lib/src/main/java/android/database/sqlite/SQLiteConnectionPool.java
//

#include "IOSClass.h"
#include "J2ObjC_source.h"
#include "android/database/sqlite/SQLiteConnection.h"
#include "android/database/sqlite/SQLiteConnectionPool.h"
#include "android/database/sqlite/SQLiteDatabase.h"
#include "android/database/sqlite/SQLiteDatabaseConfiguration.h"
#include "android/database/sqlite/SQLiteGlobal.h"
#include "android/os/SystemClock.h"
#include "android/system/CloseGuard.h"
#include "android/util/Log.h"
#include "android/util/PrefixPrinter.h"
#include "android/util/Printer.h"
#include "java/lang/Enum.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Integer.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/StringBuilder.h"
#include "java/lang/Thread.h"
#include "java/util/ArrayList.h"
#include "java/util/Map.h"
#include "java/util/Set.h"
#include "java/util/WeakHashMap.h"
#include "java/util/concurrent/atomic/AtomicBoolean.h"
#include "java/util/concurrent/locks/LockSupport.h"

@class AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter;

@interface AndroidDatabaseSqliteSQLiteConnectionPool () {
 @public
  AndroidSystemCloseGuard *mCloseGuard_;
  id mLock_;
  JavaUtilConcurrentAtomicAtomicBoolean *mConnectionLeaked_;
  AndroidDatabaseSqliteSQLiteDatabaseConfiguration *mConfiguration_;
  jint mMaxConnectionPoolSize_;
  jboolean mIsOpen_;
  jint mNextConnectionId_;
  AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *mConnectionWaiterPool_;
  AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *mConnectionWaiterQueue_;
  JavaUtilArrayList *mAvailableNonPrimaryConnections_;
  AndroidDatabaseSqliteSQLiteConnection *mAvailablePrimaryConnection_;
  JavaUtilWeakHashMap *mAcquiredConnections_;
}

- (instancetype)initWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration:(AndroidDatabaseSqliteSQLiteDatabaseConfiguration *)configuration;

- (void)open;

- (void)disposeWithBoolean:(jboolean)finalized;

- (jboolean)recycleConnectionLockedWithAndroidDatabaseSqliteSQLiteConnection:(AndroidDatabaseSqliteSQLiteConnection *)connection
      withAndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus:(AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus *)status;

- (AndroidDatabaseSqliteSQLiteConnection *)openConnectionLockedWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration:(AndroidDatabaseSqliteSQLiteDatabaseConfiguration *)configuration
                                                                                                        withBoolean:(jboolean)primaryConnection;

- (void)closeAvailableConnectionsAndLogExceptionsLocked;

- (void)closeAvailableNonPrimaryConnectionsAndLogExceptionsLocked;

- (void)closeExcessConnectionsAndLogExceptionsLocked;

- (void)closeConnectionAndLogExceptionsLockedWithAndroidDatabaseSqliteSQLiteConnection:(AndroidDatabaseSqliteSQLiteConnection *)connection;

- (void)discardAcquiredConnectionsLocked;

- (void)reconfigureAllConnectionsLocked;

- (void)markAcquiredConnectionsLockedWithAndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus:(AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus *)status;

- (AndroidDatabaseSqliteSQLiteConnection *)waitForConnectionWithNSString:(NSString *)sql
                                                                 withInt:(jint)connectionFlags;

- (void)logConnectionPoolBusyLockedWithLong:(jlong)waitMillis
                                    withInt:(jint)connectionFlags;

- (void)wakeConnectionWaitersLocked;

- (AndroidDatabaseSqliteSQLiteConnection *)tryAcquirePrimaryConnectionLockedWithInt:(jint)connectionFlags;

- (AndroidDatabaseSqliteSQLiteConnection *)tryAcquireNonPrimaryConnectionLockedWithNSString:(NSString *)sql
                                                                                    withInt:(jint)connectionFlags;

- (void)finishAcquireConnectionLockedWithAndroidDatabaseSqliteSQLiteConnection:(AndroidDatabaseSqliteSQLiteConnection *)connection
                                                                       withInt:(jint)connectionFlags;

- (jboolean)isSessionBlockingImportantConnectionWaitersLockedWithBoolean:(jboolean)holdingPrimaryConnection
                                                                 withInt:(jint)connectionFlags;

+ (jint)getPriorityWithInt:(jint)connectionFlags;

- (void)setMaxConnectionPoolSizeLocked;

- (void)throwIfClosedLocked;

- (AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *)obtainConnectionWaiterLockedWithJavaLangThread:(JavaLangThread *)thread
                                                                                                      withLong:(jlong)startTime
                                                                                                       withInt:(jint)priority
                                                                                                   withBoolean:(jboolean)wantPrimaryConnection
                                                                                                  withNSString:(NSString *)sql
                                                                                                       withInt:(jint)connectionFlags;

- (void)recycleConnectionWaiterLockedWithAndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter:(AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *)waiter;

@end

J2OBJC_FIELD_SETTER(AndroidDatabaseSqliteSQLiteConnectionPool, mCloseGuard_, AndroidSystemCloseGuard *)
J2OBJC_FIELD_SETTER(AndroidDatabaseSqliteSQLiteConnectionPool, mLock_, id)
J2OBJC_FIELD_SETTER(AndroidDatabaseSqliteSQLiteConnectionPool, mConnectionLeaked_, JavaUtilConcurrentAtomicAtomicBoolean *)
J2OBJC_FIELD_SETTER(AndroidDatabaseSqliteSQLiteConnectionPool, mConfiguration_, AndroidDatabaseSqliteSQLiteDatabaseConfiguration *)
J2OBJC_FIELD_SETTER(AndroidDatabaseSqliteSQLiteConnectionPool, mConnectionWaiterPool_, AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *)
J2OBJC_FIELD_SETTER(AndroidDatabaseSqliteSQLiteConnectionPool, mConnectionWaiterQueue_, AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *)
J2OBJC_FIELD_SETTER(AndroidDatabaseSqliteSQLiteConnectionPool, mAvailableNonPrimaryConnections_, JavaUtilArrayList *)
J2OBJC_FIELD_SETTER(AndroidDatabaseSqliteSQLiteConnectionPool, mAvailablePrimaryConnection_, AndroidDatabaseSqliteSQLiteConnection *)
J2OBJC_FIELD_SETTER(AndroidDatabaseSqliteSQLiteConnectionPool, mAcquiredConnections_, JavaUtilWeakHashMap *)

inline NSString *AndroidDatabaseSqliteSQLiteConnectionPool_get_TAG();
static NSString *AndroidDatabaseSqliteSQLiteConnectionPool_TAG = @"SQLiteConnectionPool";
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidDatabaseSqliteSQLiteConnectionPool, TAG, NSString *)

inline jlong AndroidDatabaseSqliteSQLiteConnectionPool_get_CONNECTION_POOL_BUSY_MILLIS();
#define AndroidDatabaseSqliteSQLiteConnectionPool_CONNECTION_POOL_BUSY_MILLIS 30000LL
J2OBJC_STATIC_FIELD_CONSTANT(AndroidDatabaseSqliteSQLiteConnectionPool, CONNECTION_POOL_BUSY_MILLIS, jlong)

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteConnectionPool_initWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration_(AndroidDatabaseSqliteSQLiteConnectionPool *self, AndroidDatabaseSqliteSQLiteDatabaseConfiguration *configuration);

__attribute__((unused)) static AndroidDatabaseSqliteSQLiteConnectionPool *new_AndroidDatabaseSqliteSQLiteConnectionPool_initWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration_(AndroidDatabaseSqliteSQLiteDatabaseConfiguration *configuration) NS_RETURNS_RETAINED;

__attribute__((unused)) static AndroidDatabaseSqliteSQLiteConnectionPool *create_AndroidDatabaseSqliteSQLiteConnectionPool_initWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration_(AndroidDatabaseSqliteSQLiteDatabaseConfiguration *configuration);

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteConnectionPool_open(AndroidDatabaseSqliteSQLiteConnectionPool *self);

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteConnectionPool_disposeWithBoolean_(AndroidDatabaseSqliteSQLiteConnectionPool *self, jboolean finalized);

__attribute__((unused)) static jboolean AndroidDatabaseSqliteSQLiteConnectionPool_recycleConnectionLockedWithAndroidDatabaseSqliteSQLiteConnection_withAndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_(AndroidDatabaseSqliteSQLiteConnectionPool *self, AndroidDatabaseSqliteSQLiteConnection *connection, AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus *status);

__attribute__((unused)) static AndroidDatabaseSqliteSQLiteConnection *AndroidDatabaseSqliteSQLiteConnectionPool_openConnectionLockedWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration_withBoolean_(AndroidDatabaseSqliteSQLiteConnectionPool *self, AndroidDatabaseSqliteSQLiteDatabaseConfiguration *configuration, jboolean primaryConnection);

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteConnectionPool_closeAvailableConnectionsAndLogExceptionsLocked(AndroidDatabaseSqliteSQLiteConnectionPool *self);

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteConnectionPool_closeAvailableNonPrimaryConnectionsAndLogExceptionsLocked(AndroidDatabaseSqliteSQLiteConnectionPool *self);

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteConnectionPool_closeExcessConnectionsAndLogExceptionsLocked(AndroidDatabaseSqliteSQLiteConnectionPool *self);

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteConnectionPool_closeConnectionAndLogExceptionsLockedWithAndroidDatabaseSqliteSQLiteConnection_(AndroidDatabaseSqliteSQLiteConnectionPool *self, AndroidDatabaseSqliteSQLiteConnection *connection);

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteConnectionPool_discardAcquiredConnectionsLocked(AndroidDatabaseSqliteSQLiteConnectionPool *self);

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteConnectionPool_reconfigureAllConnectionsLocked(AndroidDatabaseSqliteSQLiteConnectionPool *self);

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteConnectionPool_markAcquiredConnectionsLockedWithAndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_(AndroidDatabaseSqliteSQLiteConnectionPool *self, AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus *status);

__attribute__((unused)) static AndroidDatabaseSqliteSQLiteConnection *AndroidDatabaseSqliteSQLiteConnectionPool_waitForConnectionWithNSString_withInt_(AndroidDatabaseSqliteSQLiteConnectionPool *self, NSString *sql, jint connectionFlags);

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteConnectionPool_logConnectionPoolBusyLockedWithLong_withInt_(AndroidDatabaseSqliteSQLiteConnectionPool *self, jlong waitMillis, jint connectionFlags);

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteConnectionPool_wakeConnectionWaitersLocked(AndroidDatabaseSqliteSQLiteConnectionPool *self);

__attribute__((unused)) static AndroidDatabaseSqliteSQLiteConnection *AndroidDatabaseSqliteSQLiteConnectionPool_tryAcquirePrimaryConnectionLockedWithInt_(AndroidDatabaseSqliteSQLiteConnectionPool *self, jint connectionFlags);

__attribute__((unused)) static AndroidDatabaseSqliteSQLiteConnection *AndroidDatabaseSqliteSQLiteConnectionPool_tryAcquireNonPrimaryConnectionLockedWithNSString_withInt_(AndroidDatabaseSqliteSQLiteConnectionPool *self, NSString *sql, jint connectionFlags);

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteConnectionPool_finishAcquireConnectionLockedWithAndroidDatabaseSqliteSQLiteConnection_withInt_(AndroidDatabaseSqliteSQLiteConnectionPool *self, AndroidDatabaseSqliteSQLiteConnection *connection, jint connectionFlags);

__attribute__((unused)) static jboolean AndroidDatabaseSqliteSQLiteConnectionPool_isSessionBlockingImportantConnectionWaitersLockedWithBoolean_withInt_(AndroidDatabaseSqliteSQLiteConnectionPool *self, jboolean holdingPrimaryConnection, jint connectionFlags);

__attribute__((unused)) static jint AndroidDatabaseSqliteSQLiteConnectionPool_getPriorityWithInt_(jint connectionFlags);

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteConnectionPool_setMaxConnectionPoolSizeLocked(AndroidDatabaseSqliteSQLiteConnectionPool *self);

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteConnectionPool_throwIfClosedLocked(AndroidDatabaseSqliteSQLiteConnectionPool *self);

__attribute__((unused)) static AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *AndroidDatabaseSqliteSQLiteConnectionPool_obtainConnectionWaiterLockedWithJavaLangThread_withLong_withInt_withBoolean_withNSString_withInt_(AndroidDatabaseSqliteSQLiteConnectionPool *self, JavaLangThread *thread, jlong startTime, jint priority, jboolean wantPrimaryConnection, NSString *sql, jint connectionFlags);

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteConnectionPool_recycleConnectionWaiterLockedWithAndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter_(AndroidDatabaseSqliteSQLiteConnectionPool *self, AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *waiter);

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_initWithNSString_withInt_(AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus *self, NSString *__name, jint __ordinal);

__attribute__((unused)) static AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus *new_AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_initWithNSString_withInt_(NSString *__name, jint __ordinal) NS_RETURNS_RETAINED;

@interface AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter : NSObject {
 @public
  AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *mNext_;
  JavaLangThread *mThread_;
  jlong mStartTime_;
  jint mPriority_;
  jboolean mWantPrimaryConnection_;
  NSString *mSql_;
  jint mConnectionFlags_;
  AndroidDatabaseSqliteSQLiteConnection *mAssignedConnection_;
  JavaLangRuntimeException *mException_;
  jint mNonce_;
}

- (instancetype)init;

@end

J2OBJC_EMPTY_STATIC_INIT(AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter)

J2OBJC_FIELD_SETTER(AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter, mNext_, AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *)
J2OBJC_FIELD_SETTER(AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter, mThread_, JavaLangThread *)
J2OBJC_FIELD_SETTER(AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter, mSql_, NSString *)
J2OBJC_FIELD_SETTER(AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter, mAssignedConnection_, AndroidDatabaseSqliteSQLiteConnection *)
J2OBJC_FIELD_SETTER(AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter, mException_, JavaLangRuntimeException *)

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter_init(AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *self);

__attribute__((unused)) static AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *new_AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter_init() NS_RETURNS_RETAINED;

__attribute__((unused)) static AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *create_AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter_init();

J2OBJC_TYPE_LITERAL_HEADER(AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter)

@implementation AndroidDatabaseSqliteSQLiteConnectionPool

- (instancetype)initWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration:(AndroidDatabaseSqliteSQLiteDatabaseConfiguration *)configuration {
  AndroidDatabaseSqliteSQLiteConnectionPool_initWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration_(self, configuration);
  return self;
}

- (void)javaFinalize {
  @try {
    AndroidDatabaseSqliteSQLiteConnectionPool_disposeWithBoolean_(self, true);
  }
  @finally {
    [super javaFinalize];
  }
}

+ (AndroidDatabaseSqliteSQLiteConnectionPool *)openWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration:(AndroidDatabaseSqliteSQLiteDatabaseConfiguration *)configuration {
  return AndroidDatabaseSqliteSQLiteConnectionPool_openWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration_(configuration);
}

- (void)open {
  AndroidDatabaseSqliteSQLiteConnectionPool_open(self);
}

- (void)close {
  AndroidDatabaseSqliteSQLiteConnectionPool_disposeWithBoolean_(self, false);
}

- (void)disposeWithBoolean:(jboolean)finalized {
  AndroidDatabaseSqliteSQLiteConnectionPool_disposeWithBoolean_(self, finalized);
}

- (void)reconfigureWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration:(AndroidDatabaseSqliteSQLiteDatabaseConfiguration *)configuration {
  if (configuration == nil) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"configuration must not be null.");
  }
  @synchronized(mLock_) {
    AndroidDatabaseSqliteSQLiteConnectionPool_throwIfClosedLocked(self);
    jboolean walModeChanged = ((((AndroidDatabaseSqliteSQLiteDatabaseConfiguration *) nil_chk(configuration))->openFlags_ ^ ((AndroidDatabaseSqliteSQLiteDatabaseConfiguration *) nil_chk(mConfiguration_))->openFlags_) & AndroidDatabaseSqliteSQLiteDatabase_ENABLE_WRITE_AHEAD_LOGGING) != 0;
    if (walModeChanged) {
      if (![((JavaUtilWeakHashMap *) nil_chk(mAcquiredConnections_)) isEmpty]) {
        @throw new_JavaLangIllegalStateException_initWithNSString_(@"Write Ahead Logging (WAL) mode cannot be enabled or disabled while there are transactions in progress.  Finish all transactions and release all active database connections first.");
      }
      AndroidDatabaseSqliteSQLiteConnectionPool_closeAvailableNonPrimaryConnectionsAndLogExceptionsLocked(self);
      JreAssert(([((JavaUtilArrayList *) nil_chk(mAvailableNonPrimaryConnections_)) isEmpty]), (@"android/database/sqlite/SQLiteConnectionPool.java:280 condition failed: assert mAvailableNonPrimaryConnections.isEmpty();"));
    }
    jboolean foreignKeyModeChanged = configuration->foreignKeyConstraintsEnabled_ != mConfiguration_->foreignKeyConstraintsEnabled_;
    if (foreignKeyModeChanged) {
      if (![((JavaUtilWeakHashMap *) nil_chk(mAcquiredConnections_)) isEmpty]) {
        @throw new_JavaLangIllegalStateException_initWithNSString_(@"Foreign Key Constraints cannot be enabled or disabled while there are transactions in progress.  Finish all transactions and release all active database connections first.");
      }
    }
    if (mConfiguration_->openFlags_ != configuration->openFlags_) {
      if (walModeChanged) {
        AndroidDatabaseSqliteSQLiteConnectionPool_closeAvailableConnectionsAndLogExceptionsLocked(self);
      }
      AndroidDatabaseSqliteSQLiteConnection *newPrimaryConnection = AndroidDatabaseSqliteSQLiteConnectionPool_openConnectionLockedWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration_withBoolean_(self, configuration, true);
      AndroidDatabaseSqliteSQLiteConnectionPool_closeAvailableConnectionsAndLogExceptionsLocked(self);
      AndroidDatabaseSqliteSQLiteConnectionPool_discardAcquiredConnectionsLocked(self);
      mAvailablePrimaryConnection_ = newPrimaryConnection;
      [mConfiguration_ updateParametersFromWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration:configuration];
      AndroidDatabaseSqliteSQLiteConnectionPool_setMaxConnectionPoolSizeLocked(self);
    }
    else {
      [mConfiguration_ updateParametersFromWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration:configuration];
      AndroidDatabaseSqliteSQLiteConnectionPool_setMaxConnectionPoolSizeLocked(self);
      AndroidDatabaseSqliteSQLiteConnectionPool_closeExcessConnectionsAndLogExceptionsLocked(self);
      AndroidDatabaseSqliteSQLiteConnectionPool_reconfigureAllConnectionsLocked(self);
    }
    AndroidDatabaseSqliteSQLiteConnectionPool_wakeConnectionWaitersLocked(self);
  }
}

- (AndroidDatabaseSqliteSQLiteConnection *)acquireConnectionWithNSString:(NSString *)sql
                                                                 withInt:(jint)connectionFlags {
  return AndroidDatabaseSqliteSQLiteConnectionPool_waitForConnectionWithNSString_withInt_(self, sql, connectionFlags);
}

- (void)releaseConnectionWithAndroidDatabaseSqliteSQLiteConnection:(AndroidDatabaseSqliteSQLiteConnection *)connection {
  @synchronized(mLock_) {
    AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus *status = [((JavaUtilWeakHashMap *) nil_chk(mAcquiredConnections_)) removeWithId:connection];
    if (status == nil) {
      @throw new_JavaLangIllegalStateException_initWithNSString_(@"Cannot perform this operation because the specified connection was not acquired from this pool or has already been released.");
    }
    if (!mIsOpen_) {
      AndroidDatabaseSqliteSQLiteConnectionPool_closeConnectionAndLogExceptionsLockedWithAndroidDatabaseSqliteSQLiteConnection_(self, connection);
    }
    else if ([((AndroidDatabaseSqliteSQLiteConnection *) nil_chk(connection)) isPrimaryConnection]) {
      if (AndroidDatabaseSqliteSQLiteConnectionPool_recycleConnectionLockedWithAndroidDatabaseSqliteSQLiteConnection_withAndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_(self, connection, status)) {
        JreAssert((mAvailablePrimaryConnection_ == nil), (@"android/database/sqlite/SQLiteConnectionPool.java:378 condition failed: assert mAvailablePrimaryConnection == null;"));
        mAvailablePrimaryConnection_ = connection;
      }
      AndroidDatabaseSqliteSQLiteConnectionPool_wakeConnectionWaitersLocked(self);
    }
    else if ([((JavaUtilArrayList *) nil_chk(mAvailableNonPrimaryConnections_)) size] >= mMaxConnectionPoolSize_ - 1) {
      AndroidDatabaseSqliteSQLiteConnectionPool_closeConnectionAndLogExceptionsLockedWithAndroidDatabaseSqliteSQLiteConnection_(self, connection);
    }
    else {
      if (AndroidDatabaseSqliteSQLiteConnectionPool_recycleConnectionLockedWithAndroidDatabaseSqliteSQLiteConnection_withAndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_(self, connection, status)) {
        [mAvailableNonPrimaryConnections_ addWithId:connection];
      }
      AndroidDatabaseSqliteSQLiteConnectionPool_wakeConnectionWaitersLocked(self);
    }
  }
}

- (jboolean)recycleConnectionLockedWithAndroidDatabaseSqliteSQLiteConnection:(AndroidDatabaseSqliteSQLiteConnection *)connection
      withAndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus:(AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus *)status {
  return AndroidDatabaseSqliteSQLiteConnectionPool_recycleConnectionLockedWithAndroidDatabaseSqliteSQLiteConnection_withAndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_(self, connection, status);
}

- (jboolean)shouldYieldConnectionWithAndroidDatabaseSqliteSQLiteConnection:(AndroidDatabaseSqliteSQLiteConnection *)connection
                                                                   withInt:(jint)connectionFlags {
  @synchronized(mLock_) {
    if (![((JavaUtilWeakHashMap *) nil_chk(mAcquiredConnections_)) containsKeyWithId:connection]) {
      @throw new_JavaLangIllegalStateException_initWithNSString_(@"Cannot perform this operation because the specified connection was not acquired from this pool or has already been released.");
    }
    if (!mIsOpen_) {
      return false;
    }
    return AndroidDatabaseSqliteSQLiteConnectionPool_isSessionBlockingImportantConnectionWaitersLockedWithBoolean_withInt_(self, [((AndroidDatabaseSqliteSQLiteConnection *) nil_chk(connection)) isPrimaryConnection], connectionFlags);
  }
}

- (void)collectDbStatsWithJavaUtilArrayList:(JavaUtilArrayList *)dbStatsList {
  @synchronized(mLock_) {
    if (mAvailablePrimaryConnection_ != nil) {
      [mAvailablePrimaryConnection_ collectDbStatsWithJavaUtilArrayList:dbStatsList];
    }
    for (AndroidDatabaseSqliteSQLiteConnection * __strong connection in nil_chk(mAvailableNonPrimaryConnections_)) {
      [((AndroidDatabaseSqliteSQLiteConnection *) nil_chk(connection)) collectDbStatsWithJavaUtilArrayList:dbStatsList];
    }
    for (AndroidDatabaseSqliteSQLiteConnection * __strong connection in nil_chk([((JavaUtilWeakHashMap *) nil_chk(mAcquiredConnections_)) keySet])) {
      [((AndroidDatabaseSqliteSQLiteConnection *) nil_chk(connection)) collectDbStatsUnsafeWithJavaUtilArrayList:dbStatsList];
    }
  }
}

- (AndroidDatabaseSqliteSQLiteConnection *)openConnectionLockedWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration:(AndroidDatabaseSqliteSQLiteDatabaseConfiguration *)configuration
                                                                                                        withBoolean:(jboolean)primaryConnection {
  return AndroidDatabaseSqliteSQLiteConnectionPool_openConnectionLockedWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration_withBoolean_(self, configuration, primaryConnection);
}

- (void)onConnectionLeaked {
  AndroidUtilLog_wWithNSString_withNSString_(AndroidDatabaseSqliteSQLiteConnectionPool_TAG, JreStrcat("$$$", @"A SQLiteConnection object for database '", ((AndroidDatabaseSqliteSQLiteDatabaseConfiguration *) nil_chk(mConfiguration_))->label_, @"' was leaked!  Please fix your application to end transactions in progress properly and to close the database when it is no longer needed."));
  [((JavaUtilConcurrentAtomicAtomicBoolean *) nil_chk(mConnectionLeaked_)) setWithBoolean:true];
}

- (void)closeAvailableConnectionsAndLogExceptionsLocked {
  AndroidDatabaseSqliteSQLiteConnectionPool_closeAvailableConnectionsAndLogExceptionsLocked(self);
}

- (void)closeAvailableNonPrimaryConnectionsAndLogExceptionsLocked {
  AndroidDatabaseSqliteSQLiteConnectionPool_closeAvailableNonPrimaryConnectionsAndLogExceptionsLocked(self);
}

- (void)closeExcessConnectionsAndLogExceptionsLocked {
  AndroidDatabaseSqliteSQLiteConnectionPool_closeExcessConnectionsAndLogExceptionsLocked(self);
}

- (void)closeConnectionAndLogExceptionsLockedWithAndroidDatabaseSqliteSQLiteConnection:(AndroidDatabaseSqliteSQLiteConnection *)connection {
  AndroidDatabaseSqliteSQLiteConnectionPool_closeConnectionAndLogExceptionsLockedWithAndroidDatabaseSqliteSQLiteConnection_(self, connection);
}

- (void)discardAcquiredConnectionsLocked {
  AndroidDatabaseSqliteSQLiteConnectionPool_discardAcquiredConnectionsLocked(self);
}

- (void)reconfigureAllConnectionsLocked {
  AndroidDatabaseSqliteSQLiteConnectionPool_reconfigureAllConnectionsLocked(self);
}

- (void)markAcquiredConnectionsLockedWithAndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus:(AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus *)status {
  AndroidDatabaseSqliteSQLiteConnectionPool_markAcquiredConnectionsLockedWithAndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_(self, status);
}

- (AndroidDatabaseSqliteSQLiteConnection *)waitForConnectionWithNSString:(NSString *)sql
                                                                 withInt:(jint)connectionFlags {
  return AndroidDatabaseSqliteSQLiteConnectionPool_waitForConnectionWithNSString_withInt_(self, sql, connectionFlags);
}

- (void)logConnectionPoolBusyLockedWithLong:(jlong)waitMillis
                                    withInt:(jint)connectionFlags {
  AndroidDatabaseSqliteSQLiteConnectionPool_logConnectionPoolBusyLockedWithLong_withInt_(self, waitMillis, connectionFlags);
}

- (void)wakeConnectionWaitersLocked {
  AndroidDatabaseSqliteSQLiteConnectionPool_wakeConnectionWaitersLocked(self);
}

- (AndroidDatabaseSqliteSQLiteConnection *)tryAcquirePrimaryConnectionLockedWithInt:(jint)connectionFlags {
  return AndroidDatabaseSqliteSQLiteConnectionPool_tryAcquirePrimaryConnectionLockedWithInt_(self, connectionFlags);
}

- (AndroidDatabaseSqliteSQLiteConnection *)tryAcquireNonPrimaryConnectionLockedWithNSString:(NSString *)sql
                                                                                    withInt:(jint)connectionFlags {
  return AndroidDatabaseSqliteSQLiteConnectionPool_tryAcquireNonPrimaryConnectionLockedWithNSString_withInt_(self, sql, connectionFlags);
}

- (void)finishAcquireConnectionLockedWithAndroidDatabaseSqliteSQLiteConnection:(AndroidDatabaseSqliteSQLiteConnection *)connection
                                                                       withInt:(jint)connectionFlags {
  AndroidDatabaseSqliteSQLiteConnectionPool_finishAcquireConnectionLockedWithAndroidDatabaseSqliteSQLiteConnection_withInt_(self, connection, connectionFlags);
}

- (jboolean)isSessionBlockingImportantConnectionWaitersLockedWithBoolean:(jboolean)holdingPrimaryConnection
                                                                 withInt:(jint)connectionFlags {
  return AndroidDatabaseSqliteSQLiteConnectionPool_isSessionBlockingImportantConnectionWaitersLockedWithBoolean_withInt_(self, holdingPrimaryConnection, connectionFlags);
}

+ (jint)getPriorityWithInt:(jint)connectionFlags {
  return AndroidDatabaseSqliteSQLiteConnectionPool_getPriorityWithInt_(connectionFlags);
}

- (void)setMaxConnectionPoolSizeLocked {
  AndroidDatabaseSqliteSQLiteConnectionPool_setMaxConnectionPoolSizeLocked(self);
}

- (void)throwIfClosedLocked {
  AndroidDatabaseSqliteSQLiteConnectionPool_throwIfClosedLocked(self);
}

- (AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *)obtainConnectionWaiterLockedWithJavaLangThread:(JavaLangThread *)thread
                                                                                                      withLong:(jlong)startTime
                                                                                                       withInt:(jint)priority
                                                                                                   withBoolean:(jboolean)wantPrimaryConnection
                                                                                                  withNSString:(NSString *)sql
                                                                                                       withInt:(jint)connectionFlags {
  return AndroidDatabaseSqliteSQLiteConnectionPool_obtainConnectionWaiterLockedWithJavaLangThread_withLong_withInt_withBoolean_withNSString_withInt_(self, thread, startTime, priority, wantPrimaryConnection, sql, connectionFlags);
}

- (void)recycleConnectionWaiterLockedWithAndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter:(AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *)waiter {
  AndroidDatabaseSqliteSQLiteConnectionPool_recycleConnectionWaiterLockedWithAndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter_(self, waiter);
}

- (void)dumpWithAndroidUtilPrinter:(id<AndroidUtilPrinter>)printer
                       withBoolean:(jboolean)verbose {
  id<AndroidUtilPrinter> indentedPrinter = AndroidUtilPrefixPrinter_createWithAndroidUtilPrinter_withNSString_(printer, @"    ");
  @synchronized(mLock_) {
    [((id<AndroidUtilPrinter>) nil_chk(printer)) printlnWithNSString:JreStrcat("$$C", @"Connection pool for ", ((AndroidDatabaseSqliteSQLiteDatabaseConfiguration *) nil_chk(mConfiguration_))->path_, ':')];
    [printer printlnWithNSString:JreStrcat("$Z", @"  Open: ", mIsOpen_)];
    [printer printlnWithNSString:JreStrcat("$I", @"  Max connections: ", mMaxConnectionPoolSize_)];
    [printer printlnWithNSString:@"  Available primary connection:"];
    if (mAvailablePrimaryConnection_ != nil) {
      [mAvailablePrimaryConnection_ dumpWithAndroidUtilPrinter:indentedPrinter withBoolean:verbose];
    }
    else {
      [((id<AndroidUtilPrinter>) nil_chk(indentedPrinter)) printlnWithNSString:@"<none>"];
    }
    [printer printlnWithNSString:@"  Available non-primary connections:"];
    if (![((JavaUtilArrayList *) nil_chk(mAvailableNonPrimaryConnections_)) isEmpty]) {
      jint count = [mAvailableNonPrimaryConnections_ size];
      for (jint i = 0; i < count; i++) {
        [((AndroidDatabaseSqliteSQLiteConnection *) nil_chk([mAvailableNonPrimaryConnections_ getWithInt:i])) dumpWithAndroidUtilPrinter:indentedPrinter withBoolean:verbose];
      }
    }
    else {
      [((id<AndroidUtilPrinter>) nil_chk(indentedPrinter)) printlnWithNSString:@"<none>"];
    }
    [printer printlnWithNSString:@"  Acquired connections:"];
    if (![((JavaUtilWeakHashMap *) nil_chk(mAcquiredConnections_)) isEmpty]) {
      for (id<JavaUtilMap_Entry> __strong entry_ in nil_chk([mAcquiredConnections_ entrySet])) {
        AndroidDatabaseSqliteSQLiteConnection *connection = [((id<JavaUtilMap_Entry>) nil_chk(entry_)) getKey];
        [((AndroidDatabaseSqliteSQLiteConnection *) nil_chk(connection)) dumpUnsafeWithAndroidUtilPrinter:indentedPrinter withBoolean:verbose];
        [((id<AndroidUtilPrinter>) nil_chk(indentedPrinter)) printlnWithNSString:JreStrcat("$@", @"  Status: ", [entry_ getValue])];
      }
    }
    else {
      [((id<AndroidUtilPrinter>) nil_chk(indentedPrinter)) printlnWithNSString:@"<none>"];
    }
    [printer printlnWithNSString:@"  Connection waiters:"];
    if (mConnectionWaiterQueue_ != nil) {
      jint i = 0;
      jlong now = AndroidOsSystemClock_uptimeMillis();
      for (AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *waiter = mConnectionWaiterQueue_; waiter != nil; waiter = waiter->mNext_, i++) {
        [((id<AndroidUtilPrinter>) nil_chk(indentedPrinter)) printlnWithNSString:JreStrcat("I$F$@$I$$C", i, @": waited for ", ((now - waiter->mStartTime_) * 0.001f), @" ms - thread=", waiter->mThread_, @", priority=", waiter->mPriority_, @", sql='", waiter->mSql_, '\'')];
      }
    }
    else {
      [((id<AndroidUtilPrinter>) nil_chk(indentedPrinter)) printlnWithNSString:@"<none>"];
    }
  }
}

- (NSString *)description {
  return JreStrcat("$$", @"SQLiteConnectionPool: ", ((AndroidDatabaseSqliteSQLiteDatabaseConfiguration *) nil_chk(mConfiguration_))->path_);
}

- (void)dealloc {
  JreCheckFinalize(self, [AndroidDatabaseSqliteSQLiteConnectionPool class]);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration:", "SQLiteConnectionPool", NULL, 0x2, NULL, NULL },
    { "javaFinalize", "finalize", "V", 0x4, "Ljava.lang.Throwable;", NULL },
    { "openWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration:", "open", "Landroid.database.sqlite.SQLiteConnectionPool;", 0x9, NULL, NULL },
    { "open", NULL, "V", 0x2, NULL, NULL },
    { "close", NULL, "V", 0x1, NULL, NULL },
    { "disposeWithBoolean:", "dispose", "V", 0x2, NULL, NULL },
    { "reconfigureWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration:", "reconfigure", "V", 0x1, NULL, NULL },
    { "acquireConnectionWithNSString:withInt:", "acquireConnection", "Landroid.database.sqlite.SQLiteConnection;", 0x1, NULL, NULL },
    { "releaseConnectionWithAndroidDatabaseSqliteSQLiteConnection:", "releaseConnection", "V", 0x1, NULL, NULL },
    { "recycleConnectionLockedWithAndroidDatabaseSqliteSQLiteConnection:withAndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus:", "recycleConnectionLocked", "Z", 0x2, NULL, NULL },
    { "shouldYieldConnectionWithAndroidDatabaseSqliteSQLiteConnection:withInt:", "shouldYieldConnection", "Z", 0x1, NULL, NULL },
    { "collectDbStatsWithJavaUtilArrayList:", "collectDbStats", "V", 0x1, NULL, "(Ljava/util/ArrayList<Landroid/database/sqlite/SQLiteDebug$DbStats;>;)V" },
    { "openConnectionLockedWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration:withBoolean:", "openConnectionLocked", "Landroid.database.sqlite.SQLiteConnection;", 0x2, NULL, NULL },
    { "onConnectionLeaked", NULL, "V", 0x0, NULL, NULL },
    { "closeAvailableConnectionsAndLogExceptionsLocked", NULL, "V", 0x2, NULL, NULL },
    { "closeAvailableNonPrimaryConnectionsAndLogExceptionsLocked", NULL, "V", 0x2, NULL, NULL },
    { "closeExcessConnectionsAndLogExceptionsLocked", NULL, "V", 0x2, NULL, NULL },
    { "closeConnectionAndLogExceptionsLockedWithAndroidDatabaseSqliteSQLiteConnection:", "closeConnectionAndLogExceptionsLocked", "V", 0x2, NULL, NULL },
    { "discardAcquiredConnectionsLocked", NULL, "V", 0x2, NULL, NULL },
    { "reconfigureAllConnectionsLocked", NULL, "V", 0x2, NULL, NULL },
    { "markAcquiredConnectionsLockedWithAndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus:", "markAcquiredConnectionsLocked", "V", 0x2, NULL, NULL },
    { "waitForConnectionWithNSString:withInt:", "waitForConnection", "Landroid.database.sqlite.SQLiteConnection;", 0x2, NULL, NULL },
    { "logConnectionPoolBusyLockedWithLong:withInt:", "logConnectionPoolBusyLocked", "V", 0x2, NULL, NULL },
    { "wakeConnectionWaitersLocked", NULL, "V", 0x2, NULL, NULL },
    { "tryAcquirePrimaryConnectionLockedWithInt:", "tryAcquirePrimaryConnectionLocked", "Landroid.database.sqlite.SQLiteConnection;", 0x2, NULL, NULL },
    { "tryAcquireNonPrimaryConnectionLockedWithNSString:withInt:", "tryAcquireNonPrimaryConnectionLocked", "Landroid.database.sqlite.SQLiteConnection;", 0x2, NULL, NULL },
    { "finishAcquireConnectionLockedWithAndroidDatabaseSqliteSQLiteConnection:withInt:", "finishAcquireConnectionLocked", "V", 0x2, NULL, NULL },
    { "isSessionBlockingImportantConnectionWaitersLockedWithBoolean:withInt:", "isSessionBlockingImportantConnectionWaitersLocked", "Z", 0x2, NULL, NULL },
    { "getPriorityWithInt:", "getPriority", "I", 0xa, NULL, NULL },
    { "setMaxConnectionPoolSizeLocked", NULL, "V", 0x2, NULL, NULL },
    { "throwIfClosedLocked", NULL, "V", 0x2, NULL, NULL },
    { "obtainConnectionWaiterLockedWithJavaLangThread:withLong:withInt:withBoolean:withNSString:withInt:", "obtainConnectionWaiterLocked", "Landroid.database.sqlite.SQLiteConnectionPool$ConnectionWaiter;", 0x2, NULL, NULL },
    { "recycleConnectionWaiterLockedWithAndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter:", "recycleConnectionWaiterLocked", "V", 0x2, NULL, NULL },
    { "dumpWithAndroidUtilPrinter:withBoolean:", "dump", "V", 0x1, NULL, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x1, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "TAG", "TAG", 0x1a, "Ljava.lang.String;", &AndroidDatabaseSqliteSQLiteConnectionPool_TAG, NULL, .constantValue.asLong = 0 },
    { "CONNECTION_POOL_BUSY_MILLIS", "CONNECTION_POOL_BUSY_MILLIS", 0x1a, "J", NULL, NULL, .constantValue.asLong = AndroidDatabaseSqliteSQLiteConnectionPool_CONNECTION_POOL_BUSY_MILLIS },
    { "mCloseGuard_", NULL, 0x12, "Landroid.system.CloseGuard;", NULL, NULL, .constantValue.asLong = 0 },
    { "mLock_", NULL, 0x12, "Ljava.lang.Object;", NULL, NULL, .constantValue.asLong = 0 },
    { "mConnectionLeaked_", NULL, 0x12, "Ljava.util.concurrent.atomic.AtomicBoolean;", NULL, NULL, .constantValue.asLong = 0 },
    { "mConfiguration_", NULL, 0x12, "Landroid.database.sqlite.SQLiteDatabaseConfiguration;", NULL, NULL, .constantValue.asLong = 0 },
    { "mMaxConnectionPoolSize_", NULL, 0x2, "I", NULL, NULL, .constantValue.asLong = 0 },
    { "mIsOpen_", NULL, 0x2, "Z", NULL, NULL, .constantValue.asLong = 0 },
    { "mNextConnectionId_", NULL, 0x2, "I", NULL, NULL, .constantValue.asLong = 0 },
    { "mConnectionWaiterPool_", NULL, 0x2, "Landroid.database.sqlite.SQLiteConnectionPool$ConnectionWaiter;", NULL, NULL, .constantValue.asLong = 0 },
    { "mConnectionWaiterQueue_", NULL, 0x2, "Landroid.database.sqlite.SQLiteConnectionPool$ConnectionWaiter;", NULL, NULL, .constantValue.asLong = 0 },
    { "mAvailableNonPrimaryConnections_", NULL, 0x12, "Ljava.util.ArrayList;", NULL, "Ljava/util/ArrayList<Landroid/database/sqlite/SQLiteConnection;>;", .constantValue.asLong = 0 },
    { "mAvailablePrimaryConnection_", NULL, 0x2, "Landroid.database.sqlite.SQLiteConnection;", NULL, NULL, .constantValue.asLong = 0 },
    { "mAcquiredConnections_", NULL, 0x12, "Ljava.util.WeakHashMap;", NULL, "Ljava/util/WeakHashMap<Landroid/database/sqlite/SQLiteConnection;Landroid/database/sqlite/SQLiteConnectionPool$AcquiredConnectionStatus;>;", .constantValue.asLong = 0 },
    { "CONNECTION_FLAG_READ_ONLY", "CONNECTION_FLAG_READ_ONLY", 0x19, "I", NULL, NULL, .constantValue.asInt = AndroidDatabaseSqliteSQLiteConnectionPool_CONNECTION_FLAG_READ_ONLY },
    { "CONNECTION_FLAG_PRIMARY_CONNECTION_AFFINITY", "CONNECTION_FLAG_PRIMARY_CONNECTION_AFFINITY", 0x19, "I", NULL, NULL, .constantValue.asInt = AndroidDatabaseSqliteSQLiteConnectionPool_CONNECTION_FLAG_PRIMARY_CONNECTION_AFFINITY },
    { "CONNECTION_FLAG_INTERACTIVE", "CONNECTION_FLAG_INTERACTIVE", 0x19, "I", NULL, NULL, .constantValue.asInt = AndroidDatabaseSqliteSQLiteConnectionPool_CONNECTION_FLAG_INTERACTIVE },
  };
  static const char *inner_classes[] = {"Landroid.database.sqlite.SQLiteConnectionPool$AcquiredConnectionStatus;", "Landroid.database.sqlite.SQLiteConnectionPool$ConnectionWaiter;"};
  static const J2ObjcClassInfo _AndroidDatabaseSqliteSQLiteConnectionPool = { 2, "SQLiteConnectionPool", "android.database.sqlite", NULL, 0x11, 35, methods, 17, fields, 0, NULL, 2, inner_classes, NULL, NULL };
  return &_AndroidDatabaseSqliteSQLiteConnectionPool;
}

@end

void AndroidDatabaseSqliteSQLiteConnectionPool_initWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration_(AndroidDatabaseSqliteSQLiteConnectionPool *self, AndroidDatabaseSqliteSQLiteDatabaseConfiguration *configuration) {
  NSObject_init(self);
  self->mCloseGuard_ = AndroidSystemCloseGuard_get();
  self->mLock_ = new_NSObject_init();
  self->mConnectionLeaked_ = new_JavaUtilConcurrentAtomicAtomicBoolean_init();
  self->mAvailableNonPrimaryConnections_ = new_JavaUtilArrayList_init();
  self->mAcquiredConnections_ = new_JavaUtilWeakHashMap_init();
  self->mConfiguration_ = new_AndroidDatabaseSqliteSQLiteDatabaseConfiguration_initWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration_(configuration);
  AndroidDatabaseSqliteSQLiteConnectionPool_setMaxConnectionPoolSizeLocked(self);
}

AndroidDatabaseSqliteSQLiteConnectionPool *new_AndroidDatabaseSqliteSQLiteConnectionPool_initWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration_(AndroidDatabaseSqliteSQLiteDatabaseConfiguration *configuration) {
  AndroidDatabaseSqliteSQLiteConnectionPool *self = [AndroidDatabaseSqliteSQLiteConnectionPool alloc];
  AndroidDatabaseSqliteSQLiteConnectionPool_initWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration_(self, configuration);
  return self;
}

AndroidDatabaseSqliteSQLiteConnectionPool *create_AndroidDatabaseSqliteSQLiteConnectionPool_initWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration_(AndroidDatabaseSqliteSQLiteDatabaseConfiguration *configuration) {
  return new_AndroidDatabaseSqliteSQLiteConnectionPool_initWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration_(configuration);
}

AndroidDatabaseSqliteSQLiteConnectionPool *AndroidDatabaseSqliteSQLiteConnectionPool_openWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration_(AndroidDatabaseSqliteSQLiteDatabaseConfiguration *configuration) {
  AndroidDatabaseSqliteSQLiteConnectionPool_initialize();
  if (configuration == nil) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"configuration must not be null.");
  }
  AndroidDatabaseSqliteSQLiteConnectionPool *pool = new_AndroidDatabaseSqliteSQLiteConnectionPool_initWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration_(configuration);
  AndroidDatabaseSqliteSQLiteConnectionPool_open(pool);
  return pool;
}

void AndroidDatabaseSqliteSQLiteConnectionPool_open(AndroidDatabaseSqliteSQLiteConnectionPool *self) {
  self->mAvailablePrimaryConnection_ = AndroidDatabaseSqliteSQLiteConnectionPool_openConnectionLockedWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration_withBoolean_(self, self->mConfiguration_, true);
  self->mIsOpen_ = true;
  [((AndroidSystemCloseGuard *) nil_chk(self->mCloseGuard_)) openWithNSString:@"close"];
}

void AndroidDatabaseSqliteSQLiteConnectionPool_disposeWithBoolean_(AndroidDatabaseSqliteSQLiteConnectionPool *self, jboolean finalized) {
  if (self->mCloseGuard_ != nil) {
    if (finalized) {
      [self->mCloseGuard_ warnIfOpen];
    }
    [self->mCloseGuard_ close];
  }
  if (!finalized) {
    @synchronized(self->mLock_) {
      AndroidDatabaseSqliteSQLiteConnectionPool_throwIfClosedLocked(self);
      self->mIsOpen_ = false;
      AndroidDatabaseSqliteSQLiteConnectionPool_closeAvailableConnectionsAndLogExceptionsLocked(self);
      jint pendingCount = [((JavaUtilWeakHashMap *) nil_chk(self->mAcquiredConnections_)) size];
      if (pendingCount != 0) {
        AndroidUtilLog_iWithNSString_withNSString_(AndroidDatabaseSqliteSQLiteConnectionPool_TAG, JreStrcat("$$$I$", @"The connection pool for ", ((AndroidDatabaseSqliteSQLiteDatabaseConfiguration *) nil_chk(self->mConfiguration_))->label_, @" has been closed but there are still ", pendingCount, @" connections in use.  They will be closed as they are released back to the pool."));
      }
      AndroidDatabaseSqliteSQLiteConnectionPool_wakeConnectionWaitersLocked(self);
    }
  }
}

jboolean AndroidDatabaseSqliteSQLiteConnectionPool_recycleConnectionLockedWithAndroidDatabaseSqliteSQLiteConnection_withAndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_(AndroidDatabaseSqliteSQLiteConnectionPool *self, AndroidDatabaseSqliteSQLiteConnection *connection, AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus *status) {
  if (status == JreLoadEnum(AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus, RECONFIGURE)) {
    @try {
      [((AndroidDatabaseSqliteSQLiteConnection *) nil_chk(connection)) reconfigureWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration:self->mConfiguration_];
    }
    @catch (JavaLangRuntimeException *ex) {
      AndroidUtilLog_eWithNSString_withNSString_withNSException_(AndroidDatabaseSqliteSQLiteConnectionPool_TAG, JreStrcat("$@", @"Failed to reconfigure released connection, closing it: ", connection), ex);
      status = JreLoadEnum(AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus, DISCARD);
    }
  }
  if (status == JreLoadEnum(AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus, DISCARD)) {
    AndroidDatabaseSqliteSQLiteConnectionPool_closeConnectionAndLogExceptionsLockedWithAndroidDatabaseSqliteSQLiteConnection_(self, connection);
    return false;
  }
  return true;
}

AndroidDatabaseSqliteSQLiteConnection *AndroidDatabaseSqliteSQLiteConnectionPool_openConnectionLockedWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration_withBoolean_(AndroidDatabaseSqliteSQLiteConnectionPool *self, AndroidDatabaseSqliteSQLiteDatabaseConfiguration *configuration, jboolean primaryConnection) {
  jint connectionId = self->mNextConnectionId_++;
  return AndroidDatabaseSqliteSQLiteConnection_openWithAndroidDatabaseSqliteSQLiteConnectionPool_withAndroidDatabaseSqliteSQLiteDatabaseConfiguration_withInt_withBoolean_(self, configuration, connectionId, primaryConnection);
}

void AndroidDatabaseSqliteSQLiteConnectionPool_closeAvailableConnectionsAndLogExceptionsLocked(AndroidDatabaseSqliteSQLiteConnectionPool *self) {
  AndroidDatabaseSqliteSQLiteConnectionPool_closeAvailableNonPrimaryConnectionsAndLogExceptionsLocked(self);
  if (self->mAvailablePrimaryConnection_ != nil) {
    AndroidDatabaseSqliteSQLiteConnectionPool_closeConnectionAndLogExceptionsLockedWithAndroidDatabaseSqliteSQLiteConnection_(self, self->mAvailablePrimaryConnection_);
    self->mAvailablePrimaryConnection_ = nil;
  }
}

void AndroidDatabaseSqliteSQLiteConnectionPool_closeAvailableNonPrimaryConnectionsAndLogExceptionsLocked(AndroidDatabaseSqliteSQLiteConnectionPool *self) {
  jint count = [((JavaUtilArrayList *) nil_chk(self->mAvailableNonPrimaryConnections_)) size];
  for (jint i = 0; i < count; i++) {
    AndroidDatabaseSqliteSQLiteConnectionPool_closeConnectionAndLogExceptionsLockedWithAndroidDatabaseSqliteSQLiteConnection_(self, [self->mAvailableNonPrimaryConnections_ getWithInt:i]);
  }
  [self->mAvailableNonPrimaryConnections_ clear];
}

void AndroidDatabaseSqliteSQLiteConnectionPool_closeExcessConnectionsAndLogExceptionsLocked(AndroidDatabaseSqliteSQLiteConnectionPool *self) {
  jint availableCount = [((JavaUtilArrayList *) nil_chk(self->mAvailableNonPrimaryConnections_)) size];
  while (availableCount-- > self->mMaxConnectionPoolSize_ - 1) {
    AndroidDatabaseSqliteSQLiteConnection *connection = [self->mAvailableNonPrimaryConnections_ removeWithInt:availableCount];
    AndroidDatabaseSqliteSQLiteConnectionPool_closeConnectionAndLogExceptionsLockedWithAndroidDatabaseSqliteSQLiteConnection_(self, connection);
  }
}

void AndroidDatabaseSqliteSQLiteConnectionPool_closeConnectionAndLogExceptionsLockedWithAndroidDatabaseSqliteSQLiteConnection_(AndroidDatabaseSqliteSQLiteConnectionPool *self, AndroidDatabaseSqliteSQLiteConnection *connection) {
  @try {
    [((AndroidDatabaseSqliteSQLiteConnection *) nil_chk(connection)) close];
  }
  @catch (JavaLangRuntimeException *ex) {
    AndroidUtilLog_eWithNSString_withNSString_withNSException_(AndroidDatabaseSqliteSQLiteConnectionPool_TAG, JreStrcat("$@", @"Failed to close connection, its fate is now in the hands of the merciful GC: ", connection), ex);
  }
}

void AndroidDatabaseSqliteSQLiteConnectionPool_discardAcquiredConnectionsLocked(AndroidDatabaseSqliteSQLiteConnectionPool *self) {
  AndroidDatabaseSqliteSQLiteConnectionPool_markAcquiredConnectionsLockedWithAndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_(self, JreLoadEnum(AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus, DISCARD));
}

void AndroidDatabaseSqliteSQLiteConnectionPool_reconfigureAllConnectionsLocked(AndroidDatabaseSqliteSQLiteConnectionPool *self) {
  if (self->mAvailablePrimaryConnection_ != nil) {
    @try {
      [self->mAvailablePrimaryConnection_ reconfigureWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration:self->mConfiguration_];
    }
    @catch (JavaLangRuntimeException *ex) {
      AndroidUtilLog_eWithNSString_withNSString_withNSException_(AndroidDatabaseSqliteSQLiteConnectionPool_TAG, JreStrcat("$@", @"Failed to reconfigure available primary connection, closing it: ", self->mAvailablePrimaryConnection_), ex);
      AndroidDatabaseSqliteSQLiteConnectionPool_closeConnectionAndLogExceptionsLockedWithAndroidDatabaseSqliteSQLiteConnection_(self, self->mAvailablePrimaryConnection_);
      self->mAvailablePrimaryConnection_ = nil;
    }
  }
  jint count = [((JavaUtilArrayList *) nil_chk(self->mAvailableNonPrimaryConnections_)) size];
  for (jint i = 0; i < count; i++) {
    AndroidDatabaseSqliteSQLiteConnection *connection = [self->mAvailableNonPrimaryConnections_ getWithInt:i];
    @try {
      [((AndroidDatabaseSqliteSQLiteConnection *) nil_chk(connection)) reconfigureWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration:self->mConfiguration_];
    }
    @catch (JavaLangRuntimeException *ex) {
      AndroidUtilLog_eWithNSString_withNSString_withNSException_(AndroidDatabaseSqliteSQLiteConnectionPool_TAG, JreStrcat("$@", @"Failed to reconfigure available non-primary connection, closing it: ", connection), ex);
      AndroidDatabaseSqliteSQLiteConnectionPool_closeConnectionAndLogExceptionsLockedWithAndroidDatabaseSqliteSQLiteConnection_(self, connection);
      (void) [self->mAvailableNonPrimaryConnections_ removeWithInt:i--];
      count -= 1;
    }
  }
  AndroidDatabaseSqliteSQLiteConnectionPool_markAcquiredConnectionsLockedWithAndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_(self, JreLoadEnum(AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus, RECONFIGURE));
}

void AndroidDatabaseSqliteSQLiteConnectionPool_markAcquiredConnectionsLockedWithAndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_(AndroidDatabaseSqliteSQLiteConnectionPool *self, AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus *status) {
  if (![((JavaUtilWeakHashMap *) nil_chk(self->mAcquiredConnections_)) isEmpty]) {
    JavaUtilArrayList *keysToUpdate = new_JavaUtilArrayList_initWithInt_([self->mAcquiredConnections_ size]);
    for (id<JavaUtilMap_Entry> __strong entry_ in nil_chk([self->mAcquiredConnections_ entrySet])) {
      AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus *oldStatus = [((id<JavaUtilMap_Entry>) nil_chk(entry_)) getValue];
      if (status != oldStatus && oldStatus != JreLoadEnum(AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus, DISCARD)) {
        [keysToUpdate addWithId:[entry_ getKey]];
      }
    }
    jint updateCount = [keysToUpdate size];
    for (jint i = 0; i < updateCount; i++) {
      (void) [self->mAcquiredConnections_ putWithId:[keysToUpdate getWithInt:i] withId:status];
    }
  }
}

AndroidDatabaseSqliteSQLiteConnection *AndroidDatabaseSqliteSQLiteConnectionPool_waitForConnectionWithNSString_withInt_(AndroidDatabaseSqliteSQLiteConnectionPool *self, NSString *sql, jint connectionFlags) {
  jboolean wantPrimaryConnection = (connectionFlags & AndroidDatabaseSqliteSQLiteConnectionPool_CONNECTION_FLAG_PRIMARY_CONNECTION_AFFINITY) != 0;
  AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *waiter;
  jint nonce;
  @synchronized(self->mLock_) {
    AndroidDatabaseSqliteSQLiteConnectionPool_throwIfClosedLocked(self);
    AndroidDatabaseSqliteSQLiteConnection *connection = nil;
    if (!wantPrimaryConnection) {
      connection = AndroidDatabaseSqliteSQLiteConnectionPool_tryAcquireNonPrimaryConnectionLockedWithNSString_withInt_(self, sql, connectionFlags);
    }
    if (connection == nil) {
      connection = AndroidDatabaseSqliteSQLiteConnectionPool_tryAcquirePrimaryConnectionLockedWithInt_(self, connectionFlags);
    }
    if (connection != nil) {
      return connection;
    }
    jint priority = AndroidDatabaseSqliteSQLiteConnectionPool_getPriorityWithInt_(connectionFlags);
    jlong startTime = AndroidOsSystemClock_uptimeMillis();
    waiter = AndroidDatabaseSqliteSQLiteConnectionPool_obtainConnectionWaiterLockedWithJavaLangThread_withLong_withInt_withBoolean_withNSString_withInt_(self, JavaLangThread_currentThread(), startTime, priority, wantPrimaryConnection, sql, connectionFlags);
    AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *predecessor = nil;
    AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *successor = self->mConnectionWaiterQueue_;
    while (successor != nil) {
      if (priority > ((AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *) nil_chk(successor))->mPriority_) {
        ((AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *) nil_chk(waiter))->mNext_ = successor;
        break;
      }
      predecessor = successor;
      successor = successor->mNext_;
    }
    if (predecessor != nil) {
      predecessor->mNext_ = waiter;
    }
    else {
      self->mConnectionWaiterQueue_ = waiter;
    }
    nonce = ((AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *) nil_chk(waiter))->mNonce_;
  }
  @try {
    jlong busyTimeoutMillis = AndroidDatabaseSqliteSQLiteConnectionPool_CONNECTION_POOL_BUSY_MILLIS;
    jlong nextBusyTimeoutTime = waiter->mStartTime_ + busyTimeoutMillis;
    for (; ; ) {
      if ([((JavaUtilConcurrentAtomicAtomicBoolean *) nil_chk(self->mConnectionLeaked_)) compareAndSetWithBoolean:true withBoolean:false]) {
        @synchronized(self->mLock_) {
          AndroidDatabaseSqliteSQLiteConnectionPool_wakeConnectionWaitersLocked(self);
        }
      }
      JavaUtilConcurrentLocksLockSupport_parkNanosWithId_withLong_(self, busyTimeoutMillis * 1000000LL);
      JavaLangThread_interrupted();
      @synchronized(self->mLock_) {
        AndroidDatabaseSqliteSQLiteConnectionPool_throwIfClosedLocked(self);
        AndroidDatabaseSqliteSQLiteConnection *connection = waiter->mAssignedConnection_;
        JavaLangRuntimeException *ex = waiter->mException_;
        if (connection != nil || ex != nil) {
          AndroidDatabaseSqliteSQLiteConnectionPool_recycleConnectionWaiterLockedWithAndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter_(self, waiter);
          if (connection != nil) {
            return connection;
          }
          @throw ex;
        }
        jlong now = AndroidOsSystemClock_uptimeMillis();
        if (now < nextBusyTimeoutTime) {
          busyTimeoutMillis = now - nextBusyTimeoutTime;
        }
        else {
          AndroidDatabaseSqliteSQLiteConnectionPool_logConnectionPoolBusyLockedWithLong_withInt_(self, now - waiter->mStartTime_, connectionFlags);
          busyTimeoutMillis = AndroidDatabaseSqliteSQLiteConnectionPool_CONNECTION_POOL_BUSY_MILLIS;
          nextBusyTimeoutTime = now + busyTimeoutMillis;
        }
      }
    }
  }
  @finally {
  }
}

void AndroidDatabaseSqliteSQLiteConnectionPool_logConnectionPoolBusyLockedWithLong_withInt_(AndroidDatabaseSqliteSQLiteConnectionPool *self, jlong waitMillis, jint connectionFlags) {
  JavaLangThread *thread = JavaLangThread_currentThread();
  JavaLangStringBuilder *msg = new_JavaLangStringBuilder_init();
  (void) [((JavaLangStringBuilder *) nil_chk([msg appendWithNSString:@"The connection pool for database '"])) appendWithNSString:((AndroidDatabaseSqliteSQLiteDatabaseConfiguration *) nil_chk(self->mConfiguration_))->label_];
  (void) [msg appendWithNSString:@"' has been unable to grant a connection to thread "];
  (void) [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([msg appendWithLong:[((JavaLangThread *) nil_chk(thread)) getId]])) appendWithNSString:@" ("])) appendWithNSString:[thread getName]])) appendWithNSString:@") "];
  (void) [((JavaLangStringBuilder *) nil_chk([msg appendWithNSString:@"with flags 0x"])) appendWithNSString:JavaLangInteger_toHexStringWithInt_(connectionFlags)];
  (void) [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([msg appendWithNSString:@" for "])) appendWithFloat:waitMillis * 0.001f])) appendWithNSString:@" seconds.\n"];
  JavaUtilArrayList *requests = new_JavaUtilArrayList_init();
  jint activeConnections = 0;
  jint idleConnections = 0;
  if (![((JavaUtilWeakHashMap *) nil_chk(self->mAcquiredConnections_)) isEmpty]) {
    for (AndroidDatabaseSqliteSQLiteConnection * __strong connection in nil_chk([self->mAcquiredConnections_ keySet])) {
      NSString *description_ = [((AndroidDatabaseSqliteSQLiteConnection *) nil_chk(connection)) describeCurrentOperationUnsafe];
      if (description_ != nil) {
        [requests addWithId:description_];
        activeConnections += 1;
      }
      else {
        idleConnections += 1;
      }
    }
  }
  jint availableConnections = [((JavaUtilArrayList *) nil_chk(self->mAvailableNonPrimaryConnections_)) size];
  if (self->mAvailablePrimaryConnection_ != nil) {
    availableConnections += 1;
  }
  (void) [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([msg appendWithNSString:@"Connections: "])) appendWithInt:activeConnections])) appendWithNSString:@" active, "];
  (void) [((JavaLangStringBuilder *) nil_chk([msg appendWithInt:idleConnections])) appendWithNSString:@" idle, "];
  (void) [((JavaLangStringBuilder *) nil_chk([msg appendWithInt:availableConnections])) appendWithNSString:@" available.\n"];
  if (![requests isEmpty]) {
    (void) [msg appendWithNSString:@"\nRequests in progress:\n"];
    for (NSString * __strong request in requests) {
      (void) [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([msg appendWithNSString:@"  "])) appendWithNSString:request])) appendWithNSString:@"\n"];
    }
  }
  AndroidUtilLog_wWithNSString_withNSString_(AndroidDatabaseSqliteSQLiteConnectionPool_TAG, [msg description]);
}

void AndroidDatabaseSqliteSQLiteConnectionPool_wakeConnectionWaitersLocked(AndroidDatabaseSqliteSQLiteConnectionPool *self) {
  AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *predecessor = nil;
  AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *waiter = self->mConnectionWaiterQueue_;
  jboolean primaryConnectionNotAvailable = false;
  jboolean nonPrimaryConnectionNotAvailable = false;
  while (waiter != nil) {
    jboolean unpark = false;
    if (!self->mIsOpen_) {
      unpark = true;
    }
    else {
      @try {
        AndroidDatabaseSqliteSQLiteConnection *connection = nil;
        if (!((AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *) nil_chk(waiter))->mWantPrimaryConnection_ && !nonPrimaryConnectionNotAvailable) {
          connection = AndroidDatabaseSqliteSQLiteConnectionPool_tryAcquireNonPrimaryConnectionLockedWithNSString_withInt_(self, waiter->mSql_, waiter->mConnectionFlags_);
          if (connection == nil) {
            nonPrimaryConnectionNotAvailable = true;
          }
        }
        if (connection == nil && !primaryConnectionNotAvailable) {
          connection = AndroidDatabaseSqliteSQLiteConnectionPool_tryAcquirePrimaryConnectionLockedWithInt_(self, waiter->mConnectionFlags_);
          if (connection == nil) {
            primaryConnectionNotAvailable = true;
          }
        }
        if (connection != nil) {
          waiter->mAssignedConnection_ = connection;
          unpark = true;
        }
        else if (nonPrimaryConnectionNotAvailable && primaryConnectionNotAvailable) {
          break;
        }
      }
      @catch (JavaLangRuntimeException *ex) {
        ((AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *) nil_chk(waiter))->mException_ = ex;
        unpark = true;
      }
    }
    AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *successor = ((AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *) nil_chk(waiter))->mNext_;
    if (unpark) {
      if (predecessor != nil) {
        predecessor->mNext_ = successor;
      }
      else {
        self->mConnectionWaiterQueue_ = successor;
      }
      waiter->mNext_ = nil;
      JavaUtilConcurrentLocksLockSupport_unparkWithJavaLangThread_(waiter->mThread_);
    }
    else {
      predecessor = waiter;
    }
    waiter = successor;
  }
}

AndroidDatabaseSqliteSQLiteConnection *AndroidDatabaseSqliteSQLiteConnectionPool_tryAcquirePrimaryConnectionLockedWithInt_(AndroidDatabaseSqliteSQLiteConnectionPool *self, jint connectionFlags) {
  AndroidDatabaseSqliteSQLiteConnection *connection = self->mAvailablePrimaryConnection_;
  if (connection != nil) {
    self->mAvailablePrimaryConnection_ = nil;
    AndroidDatabaseSqliteSQLiteConnectionPool_finishAcquireConnectionLockedWithAndroidDatabaseSqliteSQLiteConnection_withInt_(self, connection, connectionFlags);
    return connection;
  }
  for (AndroidDatabaseSqliteSQLiteConnection * __strong acquiredConnection in nil_chk([((JavaUtilWeakHashMap *) nil_chk(self->mAcquiredConnections_)) keySet])) {
    if ([((AndroidDatabaseSqliteSQLiteConnection *) nil_chk(acquiredConnection)) isPrimaryConnection]) {
      return nil;
    }
  }
  connection = AndroidDatabaseSqliteSQLiteConnectionPool_openConnectionLockedWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration_withBoolean_(self, self->mConfiguration_, true);
  AndroidDatabaseSqliteSQLiteConnectionPool_finishAcquireConnectionLockedWithAndroidDatabaseSqliteSQLiteConnection_withInt_(self, connection, connectionFlags);
  return connection;
}

AndroidDatabaseSqliteSQLiteConnection *AndroidDatabaseSqliteSQLiteConnectionPool_tryAcquireNonPrimaryConnectionLockedWithNSString_withInt_(AndroidDatabaseSqliteSQLiteConnectionPool *self, NSString *sql, jint connectionFlags) {
  AndroidDatabaseSqliteSQLiteConnection *connection;
  jint availableCount = [((JavaUtilArrayList *) nil_chk(self->mAvailableNonPrimaryConnections_)) size];
  if (availableCount > 1 && sql != nil) {
    for (jint i = 0; i < availableCount; i++) {
      connection = [self->mAvailableNonPrimaryConnections_ getWithInt:i];
      if ([((AndroidDatabaseSqliteSQLiteConnection *) nil_chk(connection)) isPreparedStatementInCacheWithNSString:sql]) {
        (void) [self->mAvailableNonPrimaryConnections_ removeWithInt:i];
        AndroidDatabaseSqliteSQLiteConnectionPool_finishAcquireConnectionLockedWithAndroidDatabaseSqliteSQLiteConnection_withInt_(self, connection, connectionFlags);
        return connection;
      }
    }
  }
  if (availableCount > 0) {
    connection = [self->mAvailableNonPrimaryConnections_ removeWithInt:availableCount - 1];
    AndroidDatabaseSqliteSQLiteConnectionPool_finishAcquireConnectionLockedWithAndroidDatabaseSqliteSQLiteConnection_withInt_(self, connection, connectionFlags);
    return connection;
  }
  jint openConnections = [((JavaUtilWeakHashMap *) nil_chk(self->mAcquiredConnections_)) size];
  if (self->mAvailablePrimaryConnection_ != nil) {
    openConnections += 1;
  }
  if (openConnections >= self->mMaxConnectionPoolSize_) {
    return nil;
  }
  connection = AndroidDatabaseSqliteSQLiteConnectionPool_openConnectionLockedWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration_withBoolean_(self, self->mConfiguration_, false);
  AndroidDatabaseSqliteSQLiteConnectionPool_finishAcquireConnectionLockedWithAndroidDatabaseSqliteSQLiteConnection_withInt_(self, connection, connectionFlags);
  return connection;
}

void AndroidDatabaseSqliteSQLiteConnectionPool_finishAcquireConnectionLockedWithAndroidDatabaseSqliteSQLiteConnection_withInt_(AndroidDatabaseSqliteSQLiteConnectionPool *self, AndroidDatabaseSqliteSQLiteConnection *connection, jint connectionFlags) {
  @try {
    jboolean readOnly = (connectionFlags & AndroidDatabaseSqliteSQLiteConnectionPool_CONNECTION_FLAG_READ_ONLY) != 0;
    [((AndroidDatabaseSqliteSQLiteConnection *) nil_chk(connection)) setOnlyAllowReadOnlyOperationsWithBoolean:readOnly];
    (void) [((JavaUtilWeakHashMap *) nil_chk(self->mAcquiredConnections_)) putWithId:connection withId:JreLoadEnum(AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus, NORMAL)];
  }
  @catch (JavaLangRuntimeException *ex) {
    AndroidUtilLog_eWithNSString_withNSString_(AndroidDatabaseSqliteSQLiteConnectionPool_TAG, JreStrcat("$@$I", @"Failed to prepare acquired connection for session, closing it: ", connection, @", connectionFlags=", connectionFlags));
    AndroidDatabaseSqliteSQLiteConnectionPool_closeConnectionAndLogExceptionsLockedWithAndroidDatabaseSqliteSQLiteConnection_(self, connection);
    @throw ex;
  }
}

jboolean AndroidDatabaseSqliteSQLiteConnectionPool_isSessionBlockingImportantConnectionWaitersLockedWithBoolean_withInt_(AndroidDatabaseSqliteSQLiteConnectionPool *self, jboolean holdingPrimaryConnection, jint connectionFlags) {
  AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *waiter = self->mConnectionWaiterQueue_;
  if (waiter != nil) {
    jint priority = AndroidDatabaseSqliteSQLiteConnectionPool_getPriorityWithInt_(connectionFlags);
    do {
      if (priority > waiter->mPriority_) {
        break;
      }
      if (holdingPrimaryConnection || !waiter->mWantPrimaryConnection_) {
        return true;
      }
      waiter = waiter->mNext_;
    }
    while (waiter != nil);
  }
  return false;
}

jint AndroidDatabaseSqliteSQLiteConnectionPool_getPriorityWithInt_(jint connectionFlags) {
  AndroidDatabaseSqliteSQLiteConnectionPool_initialize();
  return (connectionFlags & AndroidDatabaseSqliteSQLiteConnectionPool_CONNECTION_FLAG_INTERACTIVE) != 0 ? 1 : 0;
}

void AndroidDatabaseSqliteSQLiteConnectionPool_setMaxConnectionPoolSizeLocked(AndroidDatabaseSqliteSQLiteConnectionPool *self) {
  if ((((AndroidDatabaseSqliteSQLiteDatabaseConfiguration *) nil_chk(self->mConfiguration_))->openFlags_ & AndroidDatabaseSqliteSQLiteDatabase_ENABLE_WRITE_AHEAD_LOGGING) != 0) {
    self->mMaxConnectionPoolSize_ = AndroidDatabaseSqliteSQLiteGlobal_getWALConnectionPoolSize();
  }
  else {
    self->mMaxConnectionPoolSize_ = 1;
  }
}

void AndroidDatabaseSqliteSQLiteConnectionPool_throwIfClosedLocked(AndroidDatabaseSqliteSQLiteConnectionPool *self) {
  if (!self->mIsOpen_) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"Cannot perform this operation because the connection pool has been closed.");
  }
}

AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *AndroidDatabaseSqliteSQLiteConnectionPool_obtainConnectionWaiterLockedWithJavaLangThread_withLong_withInt_withBoolean_withNSString_withInt_(AndroidDatabaseSqliteSQLiteConnectionPool *self, JavaLangThread *thread, jlong startTime, jint priority, jboolean wantPrimaryConnection, NSString *sql, jint connectionFlags) {
  AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *waiter = self->mConnectionWaiterPool_;
  if (waiter != nil) {
    self->mConnectionWaiterPool_ = waiter->mNext_;
    waiter->mNext_ = nil;
  }
  else {
    waiter = new_AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter_init();
  }
  ((AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *) nil_chk(waiter))->mThread_ = thread;
  waiter->mStartTime_ = startTime;
  waiter->mPriority_ = priority;
  waiter->mWantPrimaryConnection_ = wantPrimaryConnection;
  waiter->mSql_ = sql;
  waiter->mConnectionFlags_ = connectionFlags;
  return waiter;
}

void AndroidDatabaseSqliteSQLiteConnectionPool_recycleConnectionWaiterLockedWithAndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter_(AndroidDatabaseSqliteSQLiteConnectionPool *self, AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *waiter) {
  ((AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *) nil_chk(waiter))->mNext_ = self->mConnectionWaiterPool_;
  waiter->mThread_ = nil;
  waiter->mSql_ = nil;
  waiter->mAssignedConnection_ = nil;
  waiter->mException_ = nil;
  waiter->mNonce_ += 1;
  self->mConnectionWaiterPool_ = waiter;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(AndroidDatabaseSqliteSQLiteConnectionPool)

J2OBJC_INITIALIZED_DEFN(AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus)

AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus *AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_values_[3];

@implementation AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus

+ (IOSObjectArray *)values {
  return AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_values();
}

+ (AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus *)valueOfWithNSString:(NSString *)name {
  return AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_valueOfWithNSString_(name);
}

- (id)copyWithZone:(NSZone *)zone {
  return self;
}

+ (void)initialize {
  if (self == [AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus class]) {
    JreEnum(AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus, NORMAL) = new_AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_initWithNSString_withInt_(@"NORMAL", 0);
    JreEnum(AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus, RECONFIGURE) = new_AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_initWithNSString_withInt_(@"RECONFIGURE", 1);
    JreEnum(AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus, DISCARD) = new_AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_initWithNSString_withInt_(@"DISCARD", 2);
    J2OBJC_SET_INITIALIZED(AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus)
  }
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcFieldInfo fields[] = {
    { "NORMAL", "NORMAL", 0x4019, "Landroid.database.sqlite.SQLiteConnectionPool$AcquiredConnectionStatus;", &JreEnum(AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus, NORMAL), NULL, .constantValue.asLong = 0 },
    { "RECONFIGURE", "RECONFIGURE", 0x4019, "Landroid.database.sqlite.SQLiteConnectionPool$AcquiredConnectionStatus;", &JreEnum(AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus, RECONFIGURE), NULL, .constantValue.asLong = 0 },
    { "DISCARD", "DISCARD", 0x4019, "Landroid.database.sqlite.SQLiteConnectionPool$AcquiredConnectionStatus;", &JreEnum(AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus, DISCARD), NULL, .constantValue.asLong = 0 },
  };
  static const char *superclass_type_args[] = {"Landroid.database.sqlite.SQLiteConnectionPool$AcquiredConnectionStatus;"};
  static const J2ObjcClassInfo _AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus = { 2, "AcquiredConnectionStatus", "android.database.sqlite", "SQLiteConnectionPool", 0x4018, 0, NULL, 3, fields, 1, superclass_type_args, 0, NULL, NULL, "Ljava/lang/Enum<Landroid/database/sqlite/SQLiteConnectionPool$AcquiredConnectionStatus;>;" };
  return &_AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus;
}

@end

void AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_initWithNSString_withInt_(AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus *self, NSString *__name, jint __ordinal) {
  JavaLangEnum_initWithNSString_withInt_(self, __name, __ordinal);
}

AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus *new_AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_initWithNSString_withInt_(NSString *__name, jint __ordinal) {
  AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus *self = [AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus alloc];
  AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_initWithNSString_withInt_(self, __name, __ordinal);
  return self;
}

IOSObjectArray *AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_values() {
  AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_initialize();
  return [IOSObjectArray arrayWithObjects:AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_values_ count:3 type:AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_class_()];
}

AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus *AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_valueOfWithNSString_(NSString *name) {
  AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_initialize();
  for (int i = 0; i < 3; i++) {
    AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus *e = AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_values_[i];
    if ([name isEqual:[e name]]) {
      return e;
    }
  }
  @throw [[JavaLangIllegalArgumentException alloc] initWithNSString:name];
  return nil;
}

AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus *AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_fromOrdinal(NSUInteger ordinal) {
  AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_initialize();
  if (ordinal >= 3) {
    return nil;
  }
  return AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_values_[ordinal];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus)

@implementation AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", NULL, NULL, 0x2, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "mNext_", NULL, 0x1, "Landroid.database.sqlite.SQLiteConnectionPool$ConnectionWaiter;", NULL, NULL, .constantValue.asLong = 0 },
    { "mThread_", NULL, 0x1, "Ljava.lang.Thread;", NULL, NULL, .constantValue.asLong = 0 },
    { "mStartTime_", NULL, 0x1, "J", NULL, NULL, .constantValue.asLong = 0 },
    { "mPriority_", NULL, 0x1, "I", NULL, NULL, .constantValue.asLong = 0 },
    { "mWantPrimaryConnection_", NULL, 0x1, "Z", NULL, NULL, .constantValue.asLong = 0 },
    { "mSql_", NULL, 0x1, "Ljava.lang.String;", NULL, NULL, .constantValue.asLong = 0 },
    { "mConnectionFlags_", NULL, 0x1, "I", NULL, NULL, .constantValue.asLong = 0 },
    { "mAssignedConnection_", NULL, 0x1, "Landroid.database.sqlite.SQLiteConnection;", NULL, NULL, .constantValue.asLong = 0 },
    { "mException_", NULL, 0x1, "Ljava.lang.RuntimeException;", NULL, NULL, .constantValue.asLong = 0 },
    { "mNonce_", NULL, 0x1, "I", NULL, NULL, .constantValue.asLong = 0 },
  };
  static const J2ObjcClassInfo _AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter = { 2, "ConnectionWaiter", "android.database.sqlite", "SQLiteConnectionPool", 0x1a, 1, methods, 10, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter;
}

@end

void AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter_init(AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *self) {
  NSObject_init(self);
}

AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *new_AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter_init() {
  AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *self = [AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter alloc];
  AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter_init(self);
  return self;
}

AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *create_AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter_init() {
  return new_AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter_init();
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter)
