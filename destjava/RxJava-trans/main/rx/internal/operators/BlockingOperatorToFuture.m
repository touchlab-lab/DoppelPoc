//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/kgalligan/devel/xp/sourcejava/RxJava/src/main/java/rx/internal/operators/BlockingOperatorToFuture.java
//

#include "IOSClass.h"
#include "J2ObjC_source.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/InterruptedException.h"
#include "java/util/concurrent/CancellationException.h"
#include "java/util/concurrent/CountDownLatch.h"
#include "java/util/concurrent/ExecutionException.h"
#include "java/util/concurrent/Future.h"
#include "java/util/concurrent/TimeUnit.h"
#include "java/util/concurrent/TimeoutException.h"
#include "java/util/concurrent/atomic/AtomicReference.h"
#include "rx/Observable.h"
#include "rx/Subscriber.h"
#include "rx/Subscription.h"
#include "rx/internal/operators/BlockingOperatorToFuture.h"

@interface RxInternalOperatorsBlockingOperatorToFuture ()

- (instancetype)init;

@end

__attribute__((unused)) static void RxInternalOperatorsBlockingOperatorToFuture_init(RxInternalOperatorsBlockingOperatorToFuture *self);

__attribute__((unused)) static RxInternalOperatorsBlockingOperatorToFuture *new_RxInternalOperatorsBlockingOperatorToFuture_init() NS_RETURNS_RETAINED;

__attribute__((unused)) static RxInternalOperatorsBlockingOperatorToFuture *create_RxInternalOperatorsBlockingOperatorToFuture_init();

@interface RxInternalOperatorsBlockingOperatorToFuture_$1 : RxSubscriber {
 @public
  JavaUtilConcurrentCountDownLatch *val$finished_;
  JavaUtilConcurrentAtomicAtomicReference *val$error_;
  JavaUtilConcurrentAtomicAtomicReference *val$value_;
}

- (void)onCompleted;

- (void)onErrorWithNSException:(NSException *)e;
#ifdef J2OBJC_RENAME_ALIASES
#define onErrorWithJavaLangThrowable onErrorWithNSException
#endif // J2OBJC_RENAME_ALIASES

- (void)onNextWithId:(id)v;

- (instancetype)initWithJavaUtilConcurrentCountDownLatch:(JavaUtilConcurrentCountDownLatch *)capture$0
             withJavaUtilConcurrentAtomicAtomicReference:(JavaUtilConcurrentAtomicAtomicReference *)capture$1
             withJavaUtilConcurrentAtomicAtomicReference:(JavaUtilConcurrentAtomicAtomicReference *)capture$2;

@end

J2OBJC_EMPTY_STATIC_INIT(RxInternalOperatorsBlockingOperatorToFuture_$1)

J2OBJC_FIELD_SETTER(RxInternalOperatorsBlockingOperatorToFuture_$1, val$finished_, JavaUtilConcurrentCountDownLatch *)
J2OBJC_FIELD_SETTER(RxInternalOperatorsBlockingOperatorToFuture_$1, val$error_, JavaUtilConcurrentAtomicAtomicReference *)
J2OBJC_FIELD_SETTER(RxInternalOperatorsBlockingOperatorToFuture_$1, val$value_, JavaUtilConcurrentAtomicAtomicReference *)

__attribute__((unused)) static void RxInternalOperatorsBlockingOperatorToFuture_$1_initWithJavaUtilConcurrentCountDownLatch_withJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentAtomicAtomicReference_(RxInternalOperatorsBlockingOperatorToFuture_$1 *self, JavaUtilConcurrentCountDownLatch *capture$0, JavaUtilConcurrentAtomicAtomicReference *capture$1, JavaUtilConcurrentAtomicAtomicReference *capture$2);

__attribute__((unused)) static RxInternalOperatorsBlockingOperatorToFuture_$1 *new_RxInternalOperatorsBlockingOperatorToFuture_$1_initWithJavaUtilConcurrentCountDownLatch_withJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentAtomicAtomicReference_(JavaUtilConcurrentCountDownLatch *capture$0, JavaUtilConcurrentAtomicAtomicReference *capture$1, JavaUtilConcurrentAtomicAtomicReference *capture$2) NS_RETURNS_RETAINED;

__attribute__((unused)) static RxInternalOperatorsBlockingOperatorToFuture_$1 *create_RxInternalOperatorsBlockingOperatorToFuture_$1_initWithJavaUtilConcurrentCountDownLatch_withJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentAtomicAtomicReference_(JavaUtilConcurrentCountDownLatch *capture$0, JavaUtilConcurrentAtomicAtomicReference *capture$1, JavaUtilConcurrentAtomicAtomicReference *capture$2);

J2OBJC_TYPE_LITERAL_HEADER(RxInternalOperatorsBlockingOperatorToFuture_$1)

@interface RxInternalOperatorsBlockingOperatorToFuture_$2 : NSObject < JavaUtilConcurrentFuture > {
 @public
  volatile_jboolean cancelled_;
  JavaUtilConcurrentCountDownLatch *val$finished_;
  id<RxSubscription> val$s_;
  JavaUtilConcurrentAtomicAtomicReference *val$error_;
  JavaUtilConcurrentAtomicAtomicReference *val$value_;
}

- (jboolean)cancelWithBoolean:(jboolean)mayInterruptIfRunning;

- (jboolean)isCancelled;

- (jboolean)isDone;

- (id)get;

- (id)getWithLong:(jlong)timeout
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

- (id)getValue;

- (instancetype)initWithJavaUtilConcurrentCountDownLatch:(JavaUtilConcurrentCountDownLatch *)capture$0
                                      withRxSubscription:(id<RxSubscription>)capture$1
             withJavaUtilConcurrentAtomicAtomicReference:(JavaUtilConcurrentAtomicAtomicReference *)capture$2
             withJavaUtilConcurrentAtomicAtomicReference:(JavaUtilConcurrentAtomicAtomicReference *)capture$3;

@end

J2OBJC_EMPTY_STATIC_INIT(RxInternalOperatorsBlockingOperatorToFuture_$2)

J2OBJC_FIELD_SETTER(RxInternalOperatorsBlockingOperatorToFuture_$2, val$finished_, JavaUtilConcurrentCountDownLatch *)
J2OBJC_FIELD_SETTER(RxInternalOperatorsBlockingOperatorToFuture_$2, val$s_, id<RxSubscription>)
J2OBJC_FIELD_SETTER(RxInternalOperatorsBlockingOperatorToFuture_$2, val$error_, JavaUtilConcurrentAtomicAtomicReference *)
J2OBJC_FIELD_SETTER(RxInternalOperatorsBlockingOperatorToFuture_$2, val$value_, JavaUtilConcurrentAtomicAtomicReference *)

__attribute__((unused)) static id RxInternalOperatorsBlockingOperatorToFuture_$2_getValue(RxInternalOperatorsBlockingOperatorToFuture_$2 *self);

__attribute__((unused)) static void RxInternalOperatorsBlockingOperatorToFuture_$2_initWithJavaUtilConcurrentCountDownLatch_withRxSubscription_withJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentAtomicAtomicReference_(RxInternalOperatorsBlockingOperatorToFuture_$2 *self, JavaUtilConcurrentCountDownLatch *capture$0, id<RxSubscription> capture$1, JavaUtilConcurrentAtomicAtomicReference *capture$2, JavaUtilConcurrentAtomicAtomicReference *capture$3);

__attribute__((unused)) static RxInternalOperatorsBlockingOperatorToFuture_$2 *new_RxInternalOperatorsBlockingOperatorToFuture_$2_initWithJavaUtilConcurrentCountDownLatch_withRxSubscription_withJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentAtomicAtomicReference_(JavaUtilConcurrentCountDownLatch *capture$0, id<RxSubscription> capture$1, JavaUtilConcurrentAtomicAtomicReference *capture$2, JavaUtilConcurrentAtomicAtomicReference *capture$3) NS_RETURNS_RETAINED;

__attribute__((unused)) static RxInternalOperatorsBlockingOperatorToFuture_$2 *create_RxInternalOperatorsBlockingOperatorToFuture_$2_initWithJavaUtilConcurrentCountDownLatch_withRxSubscription_withJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentAtomicAtomicReference_(JavaUtilConcurrentCountDownLatch *capture$0, id<RxSubscription> capture$1, JavaUtilConcurrentAtomicAtomicReference *capture$2, JavaUtilConcurrentAtomicAtomicReference *capture$3);

J2OBJC_TYPE_LITERAL_HEADER(RxInternalOperatorsBlockingOperatorToFuture_$2)

@implementation RxInternalOperatorsBlockingOperatorToFuture

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  RxInternalOperatorsBlockingOperatorToFuture_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (id<JavaUtilConcurrentFuture>)toFutureWithRxObservable:(RxObservable *)that {
  return RxInternalOperatorsBlockingOperatorToFuture_toFutureWithRxObservable_(that);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "BlockingOperatorToFuture", NULL, 0x2, NULL, NULL },
    { "toFutureWithRxObservable:", "toFuture", "Ljava.util.concurrent.Future;", 0x9, NULL, "<T:Ljava/lang/Object;>(Lrx/Observable<+TT;>;)Ljava/util/concurrent/Future<TT;>;" },
  };
  static const J2ObjcClassInfo _RxInternalOperatorsBlockingOperatorToFuture = { 2, "BlockingOperatorToFuture", "rx.internal.operators", NULL, 0x11, 2, methods, 0, NULL, 0, NULL, 0, NULL, NULL, NULL };
  return &_RxInternalOperatorsBlockingOperatorToFuture;
}

@end

void RxInternalOperatorsBlockingOperatorToFuture_init(RxInternalOperatorsBlockingOperatorToFuture *self) {
  NSObject_init(self);
  @throw new_JavaLangIllegalStateException_initWithNSString_(@"No instances!");
}

RxInternalOperatorsBlockingOperatorToFuture *new_RxInternalOperatorsBlockingOperatorToFuture_init() {
  RxInternalOperatorsBlockingOperatorToFuture *self = [RxInternalOperatorsBlockingOperatorToFuture alloc];
  RxInternalOperatorsBlockingOperatorToFuture_init(self);
  return self;
}

RxInternalOperatorsBlockingOperatorToFuture *create_RxInternalOperatorsBlockingOperatorToFuture_init() {
  return new_RxInternalOperatorsBlockingOperatorToFuture_init();
}

id<JavaUtilConcurrentFuture> RxInternalOperatorsBlockingOperatorToFuture_toFutureWithRxObservable_(RxObservable *that) {
  RxInternalOperatorsBlockingOperatorToFuture_initialize();
  JavaUtilConcurrentCountDownLatch *finished = new_JavaUtilConcurrentCountDownLatch_initWithInt_(1);
  JavaUtilConcurrentAtomicAtomicReference *value = new_JavaUtilConcurrentAtomicAtomicReference_init();
  JavaUtilConcurrentAtomicAtomicReference *error = new_JavaUtilConcurrentAtomicAtomicReference_init();
  id<RxSubscription> s = [((RxObservable *) nil_chk([((RxObservable *) nil_chk(that)) single])) subscribeWithRxSubscriber:new_RxInternalOperatorsBlockingOperatorToFuture_$1_initWithJavaUtilConcurrentCountDownLatch_withJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentAtomicAtomicReference_(finished, error, value)];
  return new_RxInternalOperatorsBlockingOperatorToFuture_$2_initWithJavaUtilConcurrentCountDownLatch_withRxSubscription_withJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentAtomicAtomicReference_(finished, s, error, value);
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(RxInternalOperatorsBlockingOperatorToFuture)

@implementation RxInternalOperatorsBlockingOperatorToFuture_$1

- (void)onCompleted {
  [((JavaUtilConcurrentCountDownLatch *) nil_chk(val$finished_)) countDown];
}

- (void)onErrorWithNSException:(NSException *)e {
  [((JavaUtilConcurrentAtomicAtomicReference *) nil_chk(val$error_)) compareAndSetWithId:nil withId:e];
  [((JavaUtilConcurrentCountDownLatch *) nil_chk(val$finished_)) countDown];
}

- (void)onNextWithId:(id)v {
  [((JavaUtilConcurrentAtomicAtomicReference *) nil_chk(val$value_)) setWithId:v];
}

- (instancetype)initWithJavaUtilConcurrentCountDownLatch:(JavaUtilConcurrentCountDownLatch *)capture$0
             withJavaUtilConcurrentAtomicAtomicReference:(JavaUtilConcurrentAtomicAtomicReference *)capture$1
             withJavaUtilConcurrentAtomicAtomicReference:(JavaUtilConcurrentAtomicAtomicReference *)capture$2 {
  RxInternalOperatorsBlockingOperatorToFuture_$1_initWithJavaUtilConcurrentCountDownLatch_withJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentAtomicAtomicReference_(self, capture$0, capture$1, capture$2);
  return self;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "onCompleted", NULL, "V", 0x1, NULL, NULL },
    { "onErrorWithNSException:", "onError", "V", 0x1, NULL, NULL },
    { "onNextWithId:", "onNext", "V", 0x1, NULL, "(TT;)V" },
    { "initWithJavaUtilConcurrentCountDownLatch:withJavaUtilConcurrentAtomicAtomicReference:withJavaUtilConcurrentAtomicAtomicReference:", "", NULL, 0x0, NULL, "(Ljava/util/concurrent/CountDownLatch;Ljava/util/concurrent/atomic/AtomicReference<Ljava/lang/Throwable;>;Ljava/util/concurrent/atomic/AtomicReference<TT;>;)V" },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "val$finished_", NULL, 0x1012, "Ljava.util.concurrent.CountDownLatch;", NULL, NULL, .constantValue.asLong = 0 },
    { "val$error_", NULL, 0x1012, "Ljava.util.concurrent.atomic.AtomicReference;", NULL, "Ljava/util/concurrent/atomic/AtomicReference<Ljava/lang/Throwable;>;", .constantValue.asLong = 0 },
    { "val$value_", NULL, 0x1012, "Ljava.util.concurrent.atomic.AtomicReference;", NULL, "Ljava/util/concurrent/atomic/AtomicReference<TT;>;", .constantValue.asLong = 0 },
  };
  static const char *superclass_type_args[] = {"TT;"};
  static const J2ObjCEnclosingMethodInfo enclosing_method = { "RxInternalOperatorsBlockingOperatorToFuture", "toFutureWithRxObservable:" };
  static const J2ObjcClassInfo _RxInternalOperatorsBlockingOperatorToFuture_$1 = { 2, "", "rx.internal.operators", "BlockingOperatorToFuture", 0x8008, 4, methods, 3, fields, 1, superclass_type_args, 0, NULL, &enclosing_method, "Lrx/Subscriber<TT;>;" };
  return &_RxInternalOperatorsBlockingOperatorToFuture_$1;
}

@end

void RxInternalOperatorsBlockingOperatorToFuture_$1_initWithJavaUtilConcurrentCountDownLatch_withJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentAtomicAtomicReference_(RxInternalOperatorsBlockingOperatorToFuture_$1 *self, JavaUtilConcurrentCountDownLatch *capture$0, JavaUtilConcurrentAtomicAtomicReference *capture$1, JavaUtilConcurrentAtomicAtomicReference *capture$2) {
  self->val$finished_ = capture$0;
  self->val$error_ = capture$1;
  self->val$value_ = capture$2;
  RxSubscriber_init(self);
}

RxInternalOperatorsBlockingOperatorToFuture_$1 *new_RxInternalOperatorsBlockingOperatorToFuture_$1_initWithJavaUtilConcurrentCountDownLatch_withJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentAtomicAtomicReference_(JavaUtilConcurrentCountDownLatch *capture$0, JavaUtilConcurrentAtomicAtomicReference *capture$1, JavaUtilConcurrentAtomicAtomicReference *capture$2) {
  RxInternalOperatorsBlockingOperatorToFuture_$1 *self = [RxInternalOperatorsBlockingOperatorToFuture_$1 alloc];
  RxInternalOperatorsBlockingOperatorToFuture_$1_initWithJavaUtilConcurrentCountDownLatch_withJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentAtomicAtomicReference_(self, capture$0, capture$1, capture$2);
  return self;
}

RxInternalOperatorsBlockingOperatorToFuture_$1 *create_RxInternalOperatorsBlockingOperatorToFuture_$1_initWithJavaUtilConcurrentCountDownLatch_withJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentAtomicAtomicReference_(JavaUtilConcurrentCountDownLatch *capture$0, JavaUtilConcurrentAtomicAtomicReference *capture$1, JavaUtilConcurrentAtomicAtomicReference *capture$2) {
  return new_RxInternalOperatorsBlockingOperatorToFuture_$1_initWithJavaUtilConcurrentCountDownLatch_withJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentAtomicAtomicReference_(capture$0, capture$1, capture$2);
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(RxInternalOperatorsBlockingOperatorToFuture_$1)

@implementation RxInternalOperatorsBlockingOperatorToFuture_$2

- (jboolean)cancelWithBoolean:(jboolean)mayInterruptIfRunning {
  if ([((JavaUtilConcurrentCountDownLatch *) nil_chk(val$finished_)) getCount] > 0) {
    JreAssignVolatileBoolean(&cancelled_, true);
    [((id<RxSubscription>) nil_chk(val$s_)) unsubscribe];
    [val$finished_ countDown];
    return true;
  }
  else {
    return false;
  }
}

- (jboolean)isCancelled {
  return JreLoadVolatileBoolean(&cancelled_);
}

- (jboolean)isDone {
  return [((JavaUtilConcurrentCountDownLatch *) nil_chk(val$finished_)) getCount] == 0;
}

- (id)get {
  [((JavaUtilConcurrentCountDownLatch *) nil_chk(val$finished_)) await];
  return RxInternalOperatorsBlockingOperatorToFuture_$2_getValue(self);
}

- (id)getWithLong:(jlong)timeout
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit {
  if ([((JavaUtilConcurrentCountDownLatch *) nil_chk(val$finished_)) awaitWithLong:timeout withJavaUtilConcurrentTimeUnit:unit]) {
    return RxInternalOperatorsBlockingOperatorToFuture_$2_getValue(self);
  }
  else {
    @throw new_JavaUtilConcurrentTimeoutException_initWithNSString_(JreStrcat("$J$", @"Timed out after ", [((JavaUtilConcurrentTimeUnit *) nil_chk(unit)) toMillisWithLong:timeout], @"ms waiting for underlying Observable."));
  }
}

- (id)getValue {
  return RxInternalOperatorsBlockingOperatorToFuture_$2_getValue(self);
}

- (instancetype)initWithJavaUtilConcurrentCountDownLatch:(JavaUtilConcurrentCountDownLatch *)capture$0
                                      withRxSubscription:(id<RxSubscription>)capture$1
             withJavaUtilConcurrentAtomicAtomicReference:(JavaUtilConcurrentAtomicAtomicReference *)capture$2
             withJavaUtilConcurrentAtomicAtomicReference:(JavaUtilConcurrentAtomicAtomicReference *)capture$3 {
  RxInternalOperatorsBlockingOperatorToFuture_$2_initWithJavaUtilConcurrentCountDownLatch_withRxSubscription_withJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentAtomicAtomicReference_(self, capture$0, capture$1, capture$2, capture$3);
  return self;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "cancelWithBoolean:", "cancel", "Z", 0x1, NULL, NULL },
    { "isCancelled", NULL, "Z", 0x1, NULL, NULL },
    { "isDone", NULL, "Z", 0x1, NULL, NULL },
    { "get", NULL, "TT;", 0x1, "Ljava.lang.InterruptedException;Ljava.util.concurrent.ExecutionException;", "()TT;" },
    { "getWithLong:withJavaUtilConcurrentTimeUnit:", "get", "TT;", 0x1, "Ljava.lang.InterruptedException;Ljava.util.concurrent.ExecutionException;Ljava.util.concurrent.TimeoutException;", "(JLjava/util/concurrent/TimeUnit;)TT;" },
    { "getValue", NULL, "TT;", 0x2, "Ljava.util.concurrent.ExecutionException;", "()TT;" },
    { "initWithJavaUtilConcurrentCountDownLatch:withRxSubscription:withJavaUtilConcurrentAtomicAtomicReference:withJavaUtilConcurrentAtomicAtomicReference:", "", NULL, 0x0, NULL, "(Ljava/util/concurrent/CountDownLatch;Lrx/Subscription;Ljava/util/concurrent/atomic/AtomicReference<Ljava/lang/Throwable;>;Ljava/util/concurrent/atomic/AtomicReference<TT;>;)V" },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "cancelled_", NULL, 0x42, "Z", NULL, NULL, .constantValue.asLong = 0 },
    { "val$finished_", NULL, 0x1012, "Ljava.util.concurrent.CountDownLatch;", NULL, NULL, .constantValue.asLong = 0 },
    { "val$s_", NULL, 0x1012, "Lrx.Subscription;", NULL, NULL, .constantValue.asLong = 0 },
    { "val$error_", NULL, 0x1012, "Ljava.util.concurrent.atomic.AtomicReference;", NULL, "Ljava/util/concurrent/atomic/AtomicReference<Ljava/lang/Throwable;>;", .constantValue.asLong = 0 },
    { "val$value_", NULL, 0x1012, "Ljava.util.concurrent.atomic.AtomicReference;", NULL, "Ljava/util/concurrent/atomic/AtomicReference<TT;>;", .constantValue.asLong = 0 },
  };
  static const J2ObjCEnclosingMethodInfo enclosing_method = { "RxInternalOperatorsBlockingOperatorToFuture", "toFutureWithRxObservable:" };
  static const J2ObjcClassInfo _RxInternalOperatorsBlockingOperatorToFuture_$2 = { 2, "", "rx.internal.operators", "BlockingOperatorToFuture", 0x8008, 7, methods, 5, fields, 0, NULL, 0, NULL, &enclosing_method, "Ljava/lang/Object;Ljava/util/concurrent/Future<TT;>;" };
  return &_RxInternalOperatorsBlockingOperatorToFuture_$2;
}

@end

id RxInternalOperatorsBlockingOperatorToFuture_$2_getValue(RxInternalOperatorsBlockingOperatorToFuture_$2 *self) {
  if ([((JavaUtilConcurrentAtomicAtomicReference *) nil_chk(self->val$error_)) get] != nil) {
    @throw new_JavaUtilConcurrentExecutionException_initWithNSString_withNSException_(@"Observable onError", [self->val$error_ get]);
  }
  else if (JreLoadVolatileBoolean(&self->cancelled_)) {
    @throw new_JavaUtilConcurrentCancellationException_initWithNSString_(@"Subscription unsubscribed");
  }
  else {
    return [((JavaUtilConcurrentAtomicAtomicReference *) nil_chk(self->val$value_)) get];
  }
}

void RxInternalOperatorsBlockingOperatorToFuture_$2_initWithJavaUtilConcurrentCountDownLatch_withRxSubscription_withJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentAtomicAtomicReference_(RxInternalOperatorsBlockingOperatorToFuture_$2 *self, JavaUtilConcurrentCountDownLatch *capture$0, id<RxSubscription> capture$1, JavaUtilConcurrentAtomicAtomicReference *capture$2, JavaUtilConcurrentAtomicAtomicReference *capture$3) {
  self->val$finished_ = capture$0;
  self->val$s_ = capture$1;
  self->val$error_ = capture$2;
  self->val$value_ = capture$3;
  NSObject_init(self);
  JreAssignVolatileBoolean(&self->cancelled_, false);
}

RxInternalOperatorsBlockingOperatorToFuture_$2 *new_RxInternalOperatorsBlockingOperatorToFuture_$2_initWithJavaUtilConcurrentCountDownLatch_withRxSubscription_withJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentAtomicAtomicReference_(JavaUtilConcurrentCountDownLatch *capture$0, id<RxSubscription> capture$1, JavaUtilConcurrentAtomicAtomicReference *capture$2, JavaUtilConcurrentAtomicAtomicReference *capture$3) {
  RxInternalOperatorsBlockingOperatorToFuture_$2 *self = [RxInternalOperatorsBlockingOperatorToFuture_$2 alloc];
  RxInternalOperatorsBlockingOperatorToFuture_$2_initWithJavaUtilConcurrentCountDownLatch_withRxSubscription_withJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentAtomicAtomicReference_(self, capture$0, capture$1, capture$2, capture$3);
  return self;
}

RxInternalOperatorsBlockingOperatorToFuture_$2 *create_RxInternalOperatorsBlockingOperatorToFuture_$2_initWithJavaUtilConcurrentCountDownLatch_withRxSubscription_withJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentAtomicAtomicReference_(JavaUtilConcurrentCountDownLatch *capture$0, id<RxSubscription> capture$1, JavaUtilConcurrentAtomicAtomicReference *capture$2, JavaUtilConcurrentAtomicAtomicReference *capture$3) {
  return new_RxInternalOperatorsBlockingOperatorToFuture_$2_initWithJavaUtilConcurrentCountDownLatch_withRxSubscription_withJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentAtomicAtomicReference_(capture$0, capture$1, capture$2, capture$3);
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(RxInternalOperatorsBlockingOperatorToFuture_$2)
