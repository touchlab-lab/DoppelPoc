//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/kgalligan/devel/xp/sourcejava/RxJava/src/main/java/rx/schedulers/ExecutorScheduler.java
//

#include "J2ObjC_header.h"

#pragma push_macro("RxSchedulersExecutorScheduler_INCLUDE_ALL")
#ifdef RxSchedulersExecutorScheduler_RESTRICT
#define RxSchedulersExecutorScheduler_INCLUDE_ALL 0
#else
#define RxSchedulersExecutorScheduler_INCLUDE_ALL 1
#endif
#undef RxSchedulersExecutorScheduler_RESTRICT

#if !defined (RxSchedulersExecutorScheduler_) && (RxSchedulersExecutorScheduler_INCLUDE_ALL || defined(RxSchedulersExecutorScheduler_INCLUDE))
#define RxSchedulersExecutorScheduler_

#define RxScheduler_RESTRICT 1
#define RxScheduler_INCLUDE 1
#include "rx/Scheduler.h"

@class RxScheduler_Worker;
@protocol JavaUtilConcurrentExecutor;

@interface RxSchedulersExecutorScheduler : RxScheduler {
 @public
  id<JavaUtilConcurrentExecutor> executor_;
}

#pragma mark Public

- (instancetype)initWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)executor;

- (RxScheduler_Worker *)createWorker;

@end

J2OBJC_EMPTY_STATIC_INIT(RxSchedulersExecutorScheduler)

J2OBJC_FIELD_SETTER(RxSchedulersExecutorScheduler, executor_, id<JavaUtilConcurrentExecutor>)

FOUNDATION_EXPORT void RxSchedulersExecutorScheduler_initWithJavaUtilConcurrentExecutor_(RxSchedulersExecutorScheduler *self, id<JavaUtilConcurrentExecutor> executor);

FOUNDATION_EXPORT RxSchedulersExecutorScheduler *new_RxSchedulersExecutorScheduler_initWithJavaUtilConcurrentExecutor_(id<JavaUtilConcurrentExecutor> executor) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT RxSchedulersExecutorScheduler *create_RxSchedulersExecutorScheduler_initWithJavaUtilConcurrentExecutor_(id<JavaUtilConcurrentExecutor> executor);

J2OBJC_TYPE_LITERAL_HEADER(RxSchedulersExecutorScheduler)

#endif

#if !defined (RxSchedulersExecutorScheduler_ExecutorSchedulerWorker_) && (RxSchedulersExecutorScheduler_INCLUDE_ALL || defined(RxSchedulersExecutorScheduler_ExecutorSchedulerWorker_INCLUDE))
#define RxSchedulersExecutorScheduler_ExecutorSchedulerWorker_

#define RxScheduler_RESTRICT 1
#define RxScheduler_Worker_INCLUDE 1
#include "rx/Scheduler.h"

#define JavaLangRunnable_RESTRICT 1
#define JavaLangRunnable_INCLUDE 1
#include "java/lang/Runnable.h"

@class JavaUtilConcurrentAtomicAtomicInteger;
@class JavaUtilConcurrentConcurrentLinkedQueue;
@class JavaUtilConcurrentTimeUnit;
@class RxSubscriptionsCompositeSubscription;
@protocol JavaUtilConcurrentExecutor;
@protocol RxFunctionsAction0;
@protocol RxSubscription;

@interface RxSchedulersExecutorScheduler_ExecutorSchedulerWorker : RxScheduler_Worker < JavaLangRunnable > {
 @public
  id<JavaUtilConcurrentExecutor> executor_;
  RxSubscriptionsCompositeSubscription *tasks_;
  JavaUtilConcurrentConcurrentLinkedQueue *queue_;
  JavaUtilConcurrentAtomicAtomicInteger *wip_;
}

#pragma mark Public

- (instancetype)initWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)executor;

- (jboolean)isUnsubscribed;

- (void)run;

- (id<RxSubscription>)scheduleWithRxFunctionsAction0:(id<RxFunctionsAction0>)action;

- (id<RxSubscription>)scheduleWithRxFunctionsAction0:(id<RxFunctionsAction0>)action
                                            withLong:(jlong)delayTime
                      withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

- (void)unsubscribe;

@end

J2OBJC_EMPTY_STATIC_INIT(RxSchedulersExecutorScheduler_ExecutorSchedulerWorker)

J2OBJC_FIELD_SETTER(RxSchedulersExecutorScheduler_ExecutorSchedulerWorker, executor_, id<JavaUtilConcurrentExecutor>)
J2OBJC_FIELD_SETTER(RxSchedulersExecutorScheduler_ExecutorSchedulerWorker, tasks_, RxSubscriptionsCompositeSubscription *)
J2OBJC_FIELD_SETTER(RxSchedulersExecutorScheduler_ExecutorSchedulerWorker, queue_, JavaUtilConcurrentConcurrentLinkedQueue *)
J2OBJC_FIELD_SETTER(RxSchedulersExecutorScheduler_ExecutorSchedulerWorker, wip_, JavaUtilConcurrentAtomicAtomicInteger *)

FOUNDATION_EXPORT void RxSchedulersExecutorScheduler_ExecutorSchedulerWorker_initWithJavaUtilConcurrentExecutor_(RxSchedulersExecutorScheduler_ExecutorSchedulerWorker *self, id<JavaUtilConcurrentExecutor> executor);

FOUNDATION_EXPORT RxSchedulersExecutorScheduler_ExecutorSchedulerWorker *new_RxSchedulersExecutorScheduler_ExecutorSchedulerWorker_initWithJavaUtilConcurrentExecutor_(id<JavaUtilConcurrentExecutor> executor) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT RxSchedulersExecutorScheduler_ExecutorSchedulerWorker *create_RxSchedulersExecutorScheduler_ExecutorSchedulerWorker_initWithJavaUtilConcurrentExecutor_(id<JavaUtilConcurrentExecutor> executor);

J2OBJC_TYPE_LITERAL_HEADER(RxSchedulersExecutorScheduler_ExecutorSchedulerWorker)

#endif

#if !defined (RxSchedulersExecutorScheduler_ExecutorAction_) && (RxSchedulersExecutorScheduler_INCLUDE_ALL || defined(RxSchedulersExecutorScheduler_ExecutorAction_INCLUDE))
#define RxSchedulersExecutorScheduler_ExecutorAction_

#define JavaLangRunnable_RESTRICT 1
#define JavaLangRunnable_INCLUDE 1
#include "java/lang/Runnable.h"

#define RxSubscription_RESTRICT 1
#define RxSubscription_INCLUDE 1
#include "rx/Subscription.h"

@class JavaUtilConcurrentAtomicAtomicIntegerFieldUpdater;
@class RxSubscriptionsCompositeSubscription;
@protocol RxFunctionsAction0;

@interface RxSchedulersExecutorScheduler_ExecutorAction : NSObject < JavaLangRunnable, RxSubscription > {
 @public
  id<RxFunctionsAction0> actual_;
  RxSubscriptionsCompositeSubscription *parent_;
  volatile_jint unsubscribed_;
}

#pragma mark Public

- (instancetype)initWithRxFunctionsAction0:(id<RxFunctionsAction0>)actual
  withRxSubscriptionsCompositeSubscription:(RxSubscriptionsCompositeSubscription *)parent;

- (jboolean)isUnsubscribed;

- (void)run;

- (void)unsubscribe;

@end

J2OBJC_STATIC_INIT(RxSchedulersExecutorScheduler_ExecutorAction)

J2OBJC_FIELD_SETTER(RxSchedulersExecutorScheduler_ExecutorAction, actual_, id<RxFunctionsAction0>)
J2OBJC_FIELD_SETTER(RxSchedulersExecutorScheduler_ExecutorAction, parent_, RxSubscriptionsCompositeSubscription *)

inline JavaUtilConcurrentAtomicAtomicIntegerFieldUpdater *RxSchedulersExecutorScheduler_ExecutorAction_get_UNSUBSCRIBED_UPDATER();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilConcurrentAtomicAtomicIntegerFieldUpdater *RxSchedulersExecutorScheduler_ExecutorAction_UNSUBSCRIBED_UPDATER;
J2OBJC_STATIC_FIELD_OBJ_FINAL(RxSchedulersExecutorScheduler_ExecutorAction, UNSUBSCRIBED_UPDATER, JavaUtilConcurrentAtomicAtomicIntegerFieldUpdater *)

FOUNDATION_EXPORT void RxSchedulersExecutorScheduler_ExecutorAction_initWithRxFunctionsAction0_withRxSubscriptionsCompositeSubscription_(RxSchedulersExecutorScheduler_ExecutorAction *self, id<RxFunctionsAction0> actual, RxSubscriptionsCompositeSubscription *parent);

FOUNDATION_EXPORT RxSchedulersExecutorScheduler_ExecutorAction *new_RxSchedulersExecutorScheduler_ExecutorAction_initWithRxFunctionsAction0_withRxSubscriptionsCompositeSubscription_(id<RxFunctionsAction0> actual, RxSubscriptionsCompositeSubscription *parent) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT RxSchedulersExecutorScheduler_ExecutorAction *create_RxSchedulersExecutorScheduler_ExecutorAction_initWithRxFunctionsAction0_withRxSubscriptionsCompositeSubscription_(id<RxFunctionsAction0> actual, RxSubscriptionsCompositeSubscription *parent);

J2OBJC_TYPE_LITERAL_HEADER(RxSchedulersExecutorScheduler_ExecutorAction)

#endif

#pragma pop_macro("RxSchedulersExecutorScheduler_INCLUDE_ALL")
