//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/kgalligan/devel/xp/sourcejava/okio/okio/src/main/java/okio/Base64.java
//

#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/io/UnsupportedEncodingException.h"
#include "java/lang/AssertionError.h"
#include "java/lang/System.h"
#include "okio/Base64.h"

@interface OkioBase64 ()

- (instancetype)init;

@end

inline IOSByteArray *OkioBase64_get_MAP();
static IOSByteArray *OkioBase64_MAP;
J2OBJC_STATIC_FIELD_OBJ_FINAL(OkioBase64, MAP, IOSByteArray *)

__attribute__((unused)) static void OkioBase64_init(OkioBase64 *self);

__attribute__((unused)) static OkioBase64 *new_OkioBase64_init() NS_RETURNS_RETAINED;

__attribute__((unused)) static OkioBase64 *create_OkioBase64_init();

J2OBJC_INITIALIZED_DEFN(OkioBase64)

@implementation OkioBase64

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  OkioBase64_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (IOSByteArray *)decodeWithNSString:(NSString *)inArg {
  return OkioBase64_decodeWithNSString_(inArg);
}

+ (NSString *)encodeWithByteArray:(IOSByteArray *)inArg {
  return OkioBase64_encodeWithByteArray_(inArg);
}

+ (void)initialize {
  if (self == [OkioBase64 class]) {
    OkioBase64_MAP = [IOSByteArray newArrayWithBytes:(jbyte[]){ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/' } count:64];
    J2OBJC_SET_INITIALIZED(OkioBase64)
  }
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "Base64", NULL, 0x2, NULL, NULL },
    { "decodeWithNSString:", "decode", "[B", 0x9, NULL, NULL },
    { "encodeWithByteArray:", "encode", "Ljava.lang.String;", 0x9, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "MAP", "MAP", 0x1a, "[B", &OkioBase64_MAP, NULL, .constantValue.asLong = 0 },
  };
  static const J2ObjcClassInfo _OkioBase64 = { 2, "Base64", "okio", NULL, 0x10, 3, methods, 1, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_OkioBase64;
}

@end

void OkioBase64_init(OkioBase64 *self) {
  NSObject_init(self);
}

OkioBase64 *new_OkioBase64_init() {
  OkioBase64 *self = [OkioBase64 alloc];
  OkioBase64_init(self);
  return self;
}

OkioBase64 *create_OkioBase64_init() {
  return new_OkioBase64_init();
}

IOSByteArray *OkioBase64_decodeWithNSString_(NSString *inArg) {
  OkioBase64_initialize();
  jint limit = ((jint) [((NSString *) nil_chk(inArg)) length]);
  for (; limit > 0; limit--) {
    jchar c = [inArg charAtWithInt:limit - 1];
    if (c != '=' && c != 0x000a && c != 0x000d && c != ' ' && c != 0x0009) {
      break;
    }
  }
  IOSByteArray *out = [IOSByteArray newArrayWithLength:(jint) (limit * 6LL / 8LL)];
  jint outCount = 0;
  jint inCount = 0;
  jint word = 0;
  for (jint pos = 0; pos < limit; pos++) {
    jchar c = [inArg charAtWithInt:pos];
    jint bits;
    if (c >= 'A' && c <= 'Z') {
      bits = c - 65;
    }
    else if (c >= 'a' && c <= 'z') {
      bits = c - 71;
    }
    else if (c >= '0' && c <= '9') {
      bits = c + 4;
    }
    else if (c == '+') {
      bits = 62;
    }
    else if (c == '/') {
      bits = 63;
    }
    else if (c == 0x000a || c == 0x000d || c == ' ' || c == 0x0009) {
      continue;
    }
    else {
      return nil;
    }
    word = (JreLShift32(word, 6)) | (jbyte) bits;
    inCount++;
    if (inCount % 4 == 0) {
      *IOSByteArray_GetRef(out, outCount++) = (jbyte) (JreRShift32(word, 16));
      *IOSByteArray_GetRef(out, outCount++) = (jbyte) (JreRShift32(word, 8));
      *IOSByteArray_GetRef(out, outCount++) = (jbyte) word;
    }
  }
  jint lastWordChars = inCount % 4;
  if (lastWordChars == 1) {
    return nil;
  }
  else if (lastWordChars == 2) {
    word = JreLShift32(word, 12);
    *IOSByteArray_GetRef(out, outCount++) = (jbyte) (JreRShift32(word, 16));
  }
  else if (lastWordChars == 3) {
    word = JreLShift32(word, 6);
    *IOSByteArray_GetRef(out, outCount++) = (jbyte) (JreRShift32(word, 16));
    *IOSByteArray_GetRef(out, outCount++) = (jbyte) (JreRShift32(word, 8));
  }
  if (outCount == out->size_) return out;
  IOSByteArray *prefix = [IOSByteArray newArrayWithLength:outCount];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(out, 0, prefix, 0, outCount);
  return prefix;
}

NSString *OkioBase64_encodeWithByteArray_(IOSByteArray *inArg) {
  OkioBase64_initialize();
  jint length = (((IOSByteArray *) nil_chk(inArg))->size_ + 2) * 4 / 3;
  IOSByteArray *out = [IOSByteArray newArrayWithLength:length];
  jint index = 0, end = inArg->size_ - inArg->size_ % 3;
  for (jint i = 0; i < end; i += 3) {
    *IOSByteArray_GetRef(out, index++) = IOSByteArray_Get(nil_chk(OkioBase64_MAP), JreRShift32((IOSByteArray_Get(inArg, i) & (jint) 0xff), 2));
    *IOSByteArray_GetRef(out, index++) = IOSByteArray_Get(OkioBase64_MAP, (JreLShift32((IOSByteArray_Get(inArg, i) & (jint) 0x03), 4)) | (JreRShift32((IOSByteArray_Get(inArg, i + 1) & (jint) 0xff), 4)));
    *IOSByteArray_GetRef(out, index++) = IOSByteArray_Get(OkioBase64_MAP, (JreLShift32((IOSByteArray_Get(inArg, i + 1) & (jint) 0x0f), 2)) | (JreRShift32((IOSByteArray_Get(inArg, i + 2) & (jint) 0xff), 6)));
    *IOSByteArray_GetRef(out, index++) = IOSByteArray_Get(OkioBase64_MAP, (IOSByteArray_Get(inArg, i + 2) & (jint) 0x3f));
  }
  switch (inArg->size_ % 3) {
    case 1:
    *IOSByteArray_GetRef(out, index++) = IOSByteArray_Get(nil_chk(OkioBase64_MAP), JreRShift32((IOSByteArray_Get(inArg, end) & (jint) 0xff), 2));
    *IOSByteArray_GetRef(out, index++) = IOSByteArray_Get(OkioBase64_MAP, JreLShift32((IOSByteArray_Get(inArg, end) & (jint) 0x03), 4));
    *IOSByteArray_GetRef(out, index++) = '=';
    *IOSByteArray_GetRef(out, index++) = '=';
    break;
    case 2:
    *IOSByteArray_GetRef(out, index++) = IOSByteArray_Get(nil_chk(OkioBase64_MAP), JreRShift32((IOSByteArray_Get(inArg, end) & (jint) 0xff), 2));
    *IOSByteArray_GetRef(out, index++) = IOSByteArray_Get(OkioBase64_MAP, (JreLShift32((IOSByteArray_Get(inArg, end) & (jint) 0x03), 4)) | (JreRShift32((IOSByteArray_Get(inArg, end + 1) & (jint) 0xff), 4)));
    *IOSByteArray_GetRef(out, index++) = IOSByteArray_Get(OkioBase64_MAP, (JreLShift32((IOSByteArray_Get(inArg, end + 1) & (jint) 0x0f), 2)));
    *IOSByteArray_GetRef(out, index++) = '=';
    break;
  }
  @try {
    return [NSString stringWithBytes:out offset:0 length:index charsetName:@"US-ASCII"];
  }
  @catch (JavaIoUnsupportedEncodingException *e) {
    @throw new_JavaLangAssertionError_initWithId_(e);
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OkioBase64)
