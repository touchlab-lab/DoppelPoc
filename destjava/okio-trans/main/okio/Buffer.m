//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/kgalligan/devel/xp/sourcejava/okio/okio/src/main/java/okio/Buffer.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/io/EOFException.h"
#include "java/io/IOException.h"
#include "java/io/InputStream.h"
#include "java/io/OutputStream.h"
#include "java/lang/AssertionError.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Integer.h"
#include "java/lang/Long.h"
#include "java/lang/Math.h"
#include "java/lang/System.h"
#include "java/nio/charset/Charset.h"
#include "java/security/MessageDigest.h"
#include "java/security/NoSuchAlgorithmException.h"
#include "java/util/ArrayList.h"
#include "java/util/Collections.h"
#include "java/util/List.h"
#include "okio/Buffer.h"
#include "okio/BufferedSink.h"
#include "okio/ByteString.h"
#include "okio/Segment.h"
#include "okio/SegmentPool.h"
#include "okio/Sink.h"
#include "okio/Source.h"
#include "okio/Timeout.h"
#include "okio/Util.h"

@interface OkioBuffer ()

- (void)readFromWithJavaIoInputStream:(JavaIoInputStream *)inArg
                             withLong:(jlong)byteCount
                          withBoolean:(jboolean)forever;

@end

__attribute__((unused)) static void OkioBuffer_readFromWithJavaIoInputStream_withLong_withBoolean_(OkioBuffer *self, JavaIoInputStream *inArg, jlong byteCount, jboolean forever);

@interface OkioBuffer_$1 : JavaIoOutputStream {
 @public
  OkioBuffer *this$0_;
}

- (void)writeWithInt:(jint)b;

- (void)writeWithByteArray:(IOSByteArray *)data
                   withInt:(jint)offset
                   withInt:(jint)byteCount;

- (void)flush;

- (void)close;

- (NSString *)description;

- (instancetype)initWithOkioBuffer:(OkioBuffer *)outer$;

@end

J2OBJC_EMPTY_STATIC_INIT(OkioBuffer_$1)

J2OBJC_FIELD_SETTER(OkioBuffer_$1, this$0_, OkioBuffer *)

__attribute__((unused)) static void OkioBuffer_$1_initWithOkioBuffer_(OkioBuffer_$1 *self, OkioBuffer *outer$);

__attribute__((unused)) static OkioBuffer_$1 *new_OkioBuffer_$1_initWithOkioBuffer_(OkioBuffer *outer$) NS_RETURNS_RETAINED;

__attribute__((unused)) static OkioBuffer_$1 *create_OkioBuffer_$1_initWithOkioBuffer_(OkioBuffer *outer$);

J2OBJC_TYPE_LITERAL_HEADER(OkioBuffer_$1)

@interface OkioBuffer_$2 : JavaIoInputStream {
 @public
  OkioBuffer *this$0_;
}

- (jint)read;

- (jint)readWithByteArray:(IOSByteArray *)sink
                  withInt:(jint)offset
                  withInt:(jint)byteCount;

- (jint)available;

- (void)close;

- (NSString *)description;

- (instancetype)initWithOkioBuffer:(OkioBuffer *)outer$;

@end

J2OBJC_EMPTY_STATIC_INIT(OkioBuffer_$2)

J2OBJC_FIELD_SETTER(OkioBuffer_$2, this$0_, OkioBuffer *)

__attribute__((unused)) static void OkioBuffer_$2_initWithOkioBuffer_(OkioBuffer_$2 *self, OkioBuffer *outer$);

__attribute__((unused)) static OkioBuffer_$2 *new_OkioBuffer_$2_initWithOkioBuffer_(OkioBuffer *outer$) NS_RETURNS_RETAINED;

__attribute__((unused)) static OkioBuffer_$2 *create_OkioBuffer_$2_initWithOkioBuffer_(OkioBuffer *outer$);

J2OBJC_TYPE_LITERAL_HEADER(OkioBuffer_$2)

@implementation OkioBuffer

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  OkioBuffer_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (jlong)size {
  return size_;
}

- (OkioBuffer *)buffer {
  return self;
}

- (JavaIoOutputStream *)outputStream {
  return new_OkioBuffer_$1_initWithOkioBuffer_(self);
}

- (OkioBuffer *)emitCompleteSegments {
  return self;
}

- (id<OkioBufferedSink>)emit {
  return self;
}

- (jboolean)exhausted {
  return size_ == 0;
}

- (void)requireWithLong:(jlong)byteCount {
  if (self->size_ < byteCount) @throw new_JavaIoEOFException_init();
}

- (jboolean)requestWithLong:(jlong)byteCount {
  return size_ >= byteCount;
}

- (JavaIoInputStream *)inputStream {
  return new_OkioBuffer_$2_initWithOkioBuffer_(self);
}

- (OkioBuffer *)copyToWithJavaIoOutputStream:(JavaIoOutputStream *)outArg {
  return [self copyToWithJavaIoOutputStream:outArg withLong:0 withLong:size_];
}

- (OkioBuffer *)copyToWithJavaIoOutputStream:(JavaIoOutputStream *)outArg
                                    withLong:(jlong)offset
                                    withLong:(jlong)byteCount {
  if (outArg == nil) @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"out == null");
  OkioUtil_checkOffsetAndCountWithLong_withLong_withLong_(size_, offset, byteCount);
  if (byteCount == 0) return self;
  OkioSegment *s = head_;
  for (; offset >= (((OkioSegment *) nil_chk(s))->limit_ - s->pos_); s = s->next_) {
    offset -= (s->limit_ - s->pos_);
  }
  for (; byteCount > 0; s = s->next_) {
    jint pos = (jint) (((OkioSegment *) nil_chk(s))->pos_ + offset);
    jint toCopy = (jint) JavaLangMath_minWithLong_withLong_(s->limit_ - pos, byteCount);
    [((JavaIoOutputStream *) nil_chk(outArg)) writeWithByteArray:s->data_ withInt:pos withInt:toCopy];
    byteCount -= toCopy;
    offset = 0;
  }
  return self;
}

- (OkioBuffer *)copyToWithOkioBuffer:(OkioBuffer *)outArg
                            withLong:(jlong)offset
                            withLong:(jlong)byteCount {
  if (outArg == nil) @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"out == null");
  OkioUtil_checkOffsetAndCountWithLong_withLong_withLong_(size_, offset, byteCount);
  if (byteCount == 0) return self;
  OkioSegment *source = head_;
  OkioSegment *target = [((OkioBuffer *) nil_chk(outArg)) writableSegmentWithInt:1];
  outArg->size_ += byteCount;
  while (byteCount > 0) {
    while (offset >= ((OkioSegment *) nil_chk(source))->limit_ - source->pos_) {
      offset -= (source->limit_ - source->pos_);
      source = source->next_;
    }
    if (((OkioSegment *) nil_chk(target))->limit_ == OkioSegment_SIZE) {
      target = [target pushWithOkioSegment:[((OkioSegmentPool *) nil_chk(JreLoadStatic(OkioSegmentPool, INSTANCE))) take]];
    }
    jlong sourceReadable = JavaLangMath_minWithLong_withLong_(((OkioSegment *) nil_chk(source))->limit_ - (source->pos_ + offset), byteCount);
    jlong targetWritable = OkioSegment_SIZE - ((OkioSegment *) nil_chk(target))->limit_;
    jint toCopy = (jint) JavaLangMath_minWithLong_withLong_(sourceReadable, targetWritable);
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(source->data_, source->pos_ + (jint) offset, target->data_, target->limit_, toCopy);
    offset += toCopy;
    target->limit_ += toCopy;
    byteCount -= toCopy;
  }
  return self;
}

- (OkioBuffer *)writeToWithJavaIoOutputStream:(JavaIoOutputStream *)outArg {
  return [self writeToWithJavaIoOutputStream:outArg withLong:size_];
}

- (OkioBuffer *)writeToWithJavaIoOutputStream:(JavaIoOutputStream *)outArg
                                     withLong:(jlong)byteCount {
  if (outArg == nil) @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"out == null");
  OkioUtil_checkOffsetAndCountWithLong_withLong_withLong_(size_, 0, byteCount);
  OkioSegment *s = head_;
  while (byteCount > 0) {
    jint toCopy = (jint) JavaLangMath_minWithLong_withLong_(byteCount, ((OkioSegment *) nil_chk(s))->limit_ - s->pos_);
    [((JavaIoOutputStream *) nil_chk(outArg)) writeWithByteArray:s->data_ withInt:s->pos_ withInt:toCopy];
    s->pos_ += toCopy;
    size_ -= toCopy;
    byteCount -= toCopy;
    if (s->pos_ == s->limit_) {
      OkioSegment *toRecycle = s;
      head_ = s = [toRecycle pop];
      [((OkioSegmentPool *) nil_chk(JreLoadStatic(OkioSegmentPool, INSTANCE))) recycleWithOkioSegment:toRecycle];
    }
  }
  return self;
}

- (OkioBuffer *)readFromWithJavaIoInputStream:(JavaIoInputStream *)inArg {
  OkioBuffer_readFromWithJavaIoInputStream_withLong_withBoolean_(self, inArg, JavaLangLong_MAX_VALUE, true);
  return self;
}

- (OkioBuffer *)readFromWithJavaIoInputStream:(JavaIoInputStream *)inArg
                                     withLong:(jlong)byteCount {
  if (byteCount < 0) @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$J", @"byteCount < 0: ", byteCount));
  OkioBuffer_readFromWithJavaIoInputStream_withLong_withBoolean_(self, inArg, byteCount, false);
  return self;
}

- (void)readFromWithJavaIoInputStream:(JavaIoInputStream *)inArg
                             withLong:(jlong)byteCount
                          withBoolean:(jboolean)forever {
  OkioBuffer_readFromWithJavaIoInputStream_withLong_withBoolean_(self, inArg, byteCount, forever);
}

- (jlong)completeSegmentByteCount {
  jlong result = size_;
  if (result == 0) return 0;
  OkioSegment *tail = ((OkioSegment *) nil_chk(head_))->prev_;
  if (((OkioSegment *) nil_chk(tail))->limit_ < OkioSegment_SIZE) {
    result -= tail->limit_ - tail->pos_;
  }
  return result;
}

- (jbyte)readByte {
  if (size_ == 0) @throw new_JavaLangIllegalStateException_initWithNSString_(@"size == 0");
  OkioSegment *segment = head_;
  jint pos = ((OkioSegment *) nil_chk(segment))->pos_;
  jint limit = segment->limit_;
  IOSByteArray *data = segment->data_;
  jbyte b = IOSByteArray_Get(nil_chk(data), pos++);
  size_ -= 1;
  if (pos == limit) {
    head_ = [segment pop];
    [((OkioSegmentPool *) nil_chk(JreLoadStatic(OkioSegmentPool, INSTANCE))) recycleWithOkioSegment:segment];
  }
  else {
    segment->pos_ = pos;
  }
  return b;
}

- (jbyte)getByteWithLong:(jlong)pos {
  OkioUtil_checkOffsetAndCountWithLong_withLong_withLong_(size_, pos, 1);
  for (OkioSegment *s = head_; true; s = s->next_) {
    jint segmentByteCount = ((OkioSegment *) nil_chk(s))->limit_ - s->pos_;
    if (pos < segmentByteCount) return IOSByteArray_Get(nil_chk(s->data_), s->pos_ + (jint) pos);
    pos -= segmentByteCount;
  }
}

- (jshort)readShort {
  if (size_ < 2) @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$J", @"size < 2: ", size_));
  OkioSegment *segment = head_;
  jint pos = ((OkioSegment *) nil_chk(segment))->pos_;
  jint limit = segment->limit_;
  if (limit - pos < 2) {
    jint s = (JreLShift32(([self readByte] & (jint) 0xff), 8)) | ([self readByte] & (jint) 0xff);
    return (jshort) s;
  }
  IOSByteArray *data = segment->data_;
  jint unseq$1 = pos++;
  jint s = (JreLShift32((IOSByteArray_Get(nil_chk(data), unseq$1) & (jint) 0xff), 8)) | (IOSByteArray_Get(data, pos++) & (jint) 0xff);
  size_ -= 2;
  if (pos == limit) {
    head_ = [segment pop];
    [((OkioSegmentPool *) nil_chk(JreLoadStatic(OkioSegmentPool, INSTANCE))) recycleWithOkioSegment:segment];
  }
  else {
    segment->pos_ = pos;
  }
  return (jshort) s;
}

- (jint)readInt {
  if (size_ < 4) @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$J", @"size < 4: ", size_));
  OkioSegment *segment = head_;
  jint pos = ((OkioSegment *) nil_chk(segment))->pos_;
  jint limit = segment->limit_;
  if (limit - pos < 4) {
    return (JreLShift32(([self readByte] & (jint) 0xff), 24)) | (JreLShift32(([self readByte] & (jint) 0xff), 16)) | (JreLShift32(([self readByte] & (jint) 0xff), 8)) | ([self readByte] & (jint) 0xff);
  }
  IOSByteArray *data = segment->data_;
  jint unseq$1 = pos++;
  jint unseq$2 = pos++;
  jint unseq$3 = pos++;
  jint i = (JreLShift32((IOSByteArray_Get(nil_chk(data), unseq$1) & (jint) 0xff), 24)) | (JreLShift32((IOSByteArray_Get(data, unseq$2) & (jint) 0xff), 16)) | (JreLShift32((IOSByteArray_Get(data, unseq$3) & (jint) 0xff), 8)) | (IOSByteArray_Get(data, pos++) & (jint) 0xff);
  size_ -= 4;
  if (pos == limit) {
    head_ = [segment pop];
    [((OkioSegmentPool *) nil_chk(JreLoadStatic(OkioSegmentPool, INSTANCE))) recycleWithOkioSegment:segment];
  }
  else {
    segment->pos_ = pos;
  }
  return i;
}

- (jlong)readLong {
  if (size_ < 8) @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$J", @"size < 8: ", size_));
  OkioSegment *segment = head_;
  jint pos = ((OkioSegment *) nil_chk(segment))->pos_;
  jint limit = segment->limit_;
  if (limit - pos < 8) {
    return (JreLShift64(([self readInt] & (jlong) 0xffffffffLL), 32)) | ([self readInt] & (jlong) 0xffffffffLL);
  }
  IOSByteArray *data = segment->data_;
  jint unseq$1 = pos++;
  jint unseq$2 = pos++;
  jint unseq$3 = pos++;
  jint unseq$4 = pos++;
  jint unseq$5 = pos++;
  jint unseq$6 = pos++;
  jint unseq$7 = pos++;
  jlong v = (JreLShift64((IOSByteArray_Get(nil_chk(data), unseq$1) & (jlong) 0xffLL), 56)) | (JreLShift64((IOSByteArray_Get(data, unseq$2) & (jlong) 0xffLL), 48)) | (JreLShift64((IOSByteArray_Get(data, unseq$3) & (jlong) 0xffLL), 40)) | (JreLShift64((IOSByteArray_Get(data, unseq$4) & (jlong) 0xffLL), 32)) | (JreLShift64((IOSByteArray_Get(data, unseq$5) & (jlong) 0xffLL), 24)) | (JreLShift64((IOSByteArray_Get(data, unseq$6) & (jlong) 0xffLL), 16)) | (JreLShift64((IOSByteArray_Get(data, unseq$7) & (jlong) 0xffLL), 8)) | (IOSByteArray_Get(data, pos++) & (jlong) 0xffLL);
  size_ -= 8;
  if (pos == limit) {
    head_ = [segment pop];
    [((OkioSegmentPool *) nil_chk(JreLoadStatic(OkioSegmentPool, INSTANCE))) recycleWithOkioSegment:segment];
  }
  else {
    segment->pos_ = pos;
  }
  return v;
}

- (jshort)readShortLe {
  return OkioUtil_reverseBytesShortWithShort_([self readShort]);
}

- (jint)readIntLe {
  return OkioUtil_reverseBytesIntWithInt_([self readInt]);
}

- (jlong)readLongLe {
  return OkioUtil_reverseBytesLongWithLong_([self readLong]);
}

- (OkioByteString *)readByteString {
  return new_OkioByteString_initWithByteArray_([self readByteArray]);
}

- (OkioByteString *)readByteStringWithLong:(jlong)byteCount {
  return new_OkioByteString_initWithByteArray_([self readByteArrayWithLong:byteCount]);
}

- (void)readFullyWithOkioBuffer:(OkioBuffer *)sink
                       withLong:(jlong)byteCount {
  if (size_ < byteCount) {
    [((OkioBuffer *) nil_chk(sink)) writeWithOkioBuffer:self withLong:size_];
    @throw new_JavaIoEOFException_init();
  }
  [((OkioBuffer *) nil_chk(sink)) writeWithOkioBuffer:self withLong:byteCount];
}

- (jlong)readAllWithOkioSink:(id<OkioSink>)sink {
  jlong byteCount = size_;
  if (byteCount > 0) {
    [((id<OkioSink>) nil_chk(sink)) writeWithOkioBuffer:self withLong:byteCount];
  }
  return byteCount;
}

- (NSString *)readUtf8 {
  @try {
    return [self readStringWithLong:size_ withJavaNioCharsetCharset:JreLoadStatic(OkioUtil, UTF_8)];
  }
  @catch (JavaIoEOFException *e) {
    @throw new_JavaLangAssertionError_initWithId_(e);
  }
}

- (NSString *)readUtf8WithLong:(jlong)byteCount {
  return [self readStringWithLong:byteCount withJavaNioCharsetCharset:JreLoadStatic(OkioUtil, UTF_8)];
}

- (NSString *)readStringWithJavaNioCharsetCharset:(JavaNioCharsetCharset *)charset {
  @try {
    return [self readStringWithLong:size_ withJavaNioCharsetCharset:charset];
  }
  @catch (JavaIoEOFException *e) {
    @throw new_JavaLangAssertionError_initWithId_(e);
  }
}

- (NSString *)readStringWithLong:(jlong)byteCount
       withJavaNioCharsetCharset:(JavaNioCharsetCharset *)charset {
  OkioUtil_checkOffsetAndCountWithLong_withLong_withLong_(size_, 0, byteCount);
  if (charset == nil) @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"charset == null");
  if (byteCount > JavaLangInteger_MAX_VALUE) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$J", @"byteCount > Integer.MAX_VALUE: ", byteCount));
  }
  if (byteCount == 0) return @"";
  OkioSegment *head = self->head_;
  if (((OkioSegment *) nil_chk(head))->pos_ + byteCount > head->limit_) {
    return [NSString stringWithBytes:[self readByteArrayWithLong:byteCount] charset:charset];
  }
  NSString *result = [NSString stringWithBytes:head->data_ offset:head->pos_ length:(jint) byteCount charset:charset];
  head->pos_ += byteCount;
  size_ -= byteCount;
  if (head->pos_ == head->limit_) {
    self->head_ = [head pop];
    [((OkioSegmentPool *) nil_chk(JreLoadStatic(OkioSegmentPool, INSTANCE))) recycleWithOkioSegment:head];
  }
  return result;
}

- (NSString *)readUtf8Line {
  jlong newline = [self indexOfWithByte:(jbyte) 0x000a];
  if (newline == -1) {
    return size_ != 0 ? [self readUtf8WithLong:size_] : nil;
  }
  return [self readUtf8LineWithLong:newline];
}

- (NSString *)readUtf8LineStrict {
  jlong newline = [self indexOfWithByte:(jbyte) 0x000a];
  if (newline == -1) @throw new_JavaIoEOFException_init();
  return [self readUtf8LineWithLong:newline];
}

- (NSString *)readUtf8LineWithLong:(jlong)newline {
  if (newline > 0 && [self getByteWithLong:newline - 1] == 0x000d) {
    NSString *result = [self readUtf8WithLong:(newline - 1)];
    [self skipWithLong:2];
    return result;
  }
  else {
    NSString *result = [self readUtf8WithLong:newline];
    [self skipWithLong:1];
    return result;
  }
}

- (IOSByteArray *)readByteArray {
  @try {
    return [self readByteArrayWithLong:size_];
  }
  @catch (JavaIoEOFException *e) {
    @throw new_JavaLangAssertionError_initWithId_(e);
  }
}

- (IOSByteArray *)readByteArrayWithLong:(jlong)byteCount {
  OkioUtil_checkOffsetAndCountWithLong_withLong_withLong_(self->size_, 0, byteCount);
  if (byteCount > JavaLangInteger_MAX_VALUE) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$J", @"byteCount > Integer.MAX_VALUE: ", byteCount));
  }
  IOSByteArray *result = [IOSByteArray newArrayWithLength:(jint) byteCount];
  [self readFullyWithByteArray:result];
  return result;
}

- (jint)readWithByteArray:(IOSByteArray *)sink {
  return [self readWithByteArray:sink withInt:0 withInt:((IOSByteArray *) nil_chk(sink))->size_];
}

- (void)readFullyWithByteArray:(IOSByteArray *)sink {
  jint offset = 0;
  while (offset < ((IOSByteArray *) nil_chk(sink))->size_) {
    jint read = [self readWithByteArray:sink withInt:offset withInt:sink->size_ - offset];
    if (read == -1) @throw new_JavaIoEOFException_init();
    offset += read;
  }
}

- (jint)readWithByteArray:(IOSByteArray *)sink
                  withInt:(jint)offset
                  withInt:(jint)byteCount {
  OkioUtil_checkOffsetAndCountWithLong_withLong_withLong_(((IOSByteArray *) nil_chk(sink))->size_, offset, byteCount);
  OkioSegment *s = self->head_;
  if (s == nil) return -1;
  jint toCopy = JavaLangMath_minWithInt_withInt_(byteCount, ((OkioSegment *) nil_chk(s))->limit_ - s->pos_);
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(s->data_, s->pos_, sink, offset, toCopy);
  s->pos_ += toCopy;
  self->size_ -= toCopy;
  if (s->pos_ == s->limit_) {
    self->head_ = [s pop];
    [((OkioSegmentPool *) nil_chk(JreLoadStatic(OkioSegmentPool, INSTANCE))) recycleWithOkioSegment:s];
  }
  return toCopy;
}

- (void)clear {
  @try {
    [self skipWithLong:size_];
  }
  @catch (JavaIoEOFException *e) {
    @throw new_JavaLangAssertionError_initWithId_(e);
  }
}

- (void)skipWithLong:(jlong)byteCount {
  while (byteCount > 0) {
    if (head_ == nil) @throw new_JavaIoEOFException_init();
    jint toSkip = (jint) JavaLangMath_minWithLong_withLong_(byteCount, ((OkioSegment *) nil_chk(head_))->limit_ - head_->pos_);
    size_ -= toSkip;
    byteCount -= toSkip;
    head_->pos_ += toSkip;
    if (head_->pos_ == head_->limit_) {
      OkioSegment *toRecycle = head_;
      head_ = [toRecycle pop];
      [((OkioSegmentPool *) nil_chk(JreLoadStatic(OkioSegmentPool, INSTANCE))) recycleWithOkioSegment:toRecycle];
    }
  }
}

- (OkioBuffer *)writeWithOkioByteString:(OkioByteString *)byteString {
  if (byteString == nil) @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"byteString == null");
  return [self writeWithByteArray:((OkioByteString *) nil_chk(byteString))->data_ withInt:0 withInt:((IOSByteArray *) nil_chk(byteString->data_))->size_];
}

- (OkioBuffer *)writeUtf8WithNSString:(NSString *)string {
  if (string == nil) @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"string == null");
  for (jint i = 0, length = ((jint) [((NSString *) nil_chk(string)) length]); i < length; ) {
    jint c = [string charAtWithInt:i];
    if (c < (jint) 0x80) {
      OkioSegment *tail = [self writableSegmentWithInt:1];
      IOSByteArray *data = ((OkioSegment *) nil_chk(tail))->data_;
      jint segmentOffset = tail->limit_ - i;
      jint runLimit = JavaLangMath_minWithInt_withInt_(length, OkioSegment_SIZE - segmentOffset);
      *IOSByteArray_GetRef(nil_chk(data), segmentOffset + i++) = (jbyte) c;
      while (i < runLimit) {
        c = [string charAtWithInt:i];
        if (c >= (jint) 0x80) break;
        *IOSByteArray_GetRef(data, segmentOffset + i++) = (jbyte) c;
      }
      jint runSize = i + segmentOffset - tail->limit_;
      tail->limit_ += runSize;
      size_ += runSize;
    }
    else if (c < (jint) 0x800) {
      (void) [self writeByteWithInt:(JreRShift32(c, 6)) | (jint) 0xc0];
      (void) [self writeByteWithInt:(c & (jint) 0x3f) | (jint) 0x80];
      i++;
    }
    else if (c < (jint) 0xd800 || c > (jint) 0xdfff) {
      (void) [self writeByteWithInt:(JreRShift32(c, 12)) | (jint) 0xe0];
      (void) [self writeByteWithInt:((JreRShift32(c, 6)) & (jint) 0x3f) | (jint) 0x80];
      (void) [self writeByteWithInt:(c & (jint) 0x3f) | (jint) 0x80];
      i++;
    }
    else {
      jint low = i + 1 < length ? [string charAtWithInt:i + 1] : 0;
      if (c > (jint) 0xdbff || low < (jint) 0xdc00 || low > (jint) 0xdfff) {
        (void) [self writeByteWithInt:'?'];
        i++;
        continue;
      }
      jint codePoint = (jint) 0x010000 + ((JreLShift32((c & ~(jint) 0xd800), 10)) | (low & ~(jint) 0xdc00));
      (void) [self writeByteWithInt:(JreRShift32(codePoint, 18)) | (jint) 0xf0];
      (void) [self writeByteWithInt:((JreRShift32(codePoint, 12)) & (jint) 0x3f) | (jint) 0x80];
      (void) [self writeByteWithInt:((JreRShift32(codePoint, 6)) & (jint) 0x3f) | (jint) 0x80];
      (void) [self writeByteWithInt:(codePoint & (jint) 0x3f) | (jint) 0x80];
      i += 2;
    }
  }
  return self;
}

- (OkioBuffer *)writeStringWithNSString:(NSString *)string
              withJavaNioCharsetCharset:(JavaNioCharsetCharset *)charset {
  if (string == nil) @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"string == null");
  if (charset == nil) @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"charset == null");
  if ([((JavaNioCharsetCharset *) nil_chk(charset)) isEqual:JreLoadStatic(OkioUtil, UTF_8)]) return [self writeUtf8WithNSString:string];
  IOSByteArray *data = [((NSString *) nil_chk(string)) getBytesWithCharset:charset];
  return [self writeWithByteArray:data withInt:0 withInt:((IOSByteArray *) nil_chk(data))->size_];
}

- (OkioBuffer *)writeWithByteArray:(IOSByteArray *)source {
  if (source == nil) @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"source == null");
  return [self writeWithByteArray:source withInt:0 withInt:((IOSByteArray *) nil_chk(source))->size_];
}

- (OkioBuffer *)writeWithByteArray:(IOSByteArray *)source
                           withInt:(jint)offset
                           withInt:(jint)byteCount {
  if (source == nil) @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"source == null");
  OkioUtil_checkOffsetAndCountWithLong_withLong_withLong_(((IOSByteArray *) nil_chk(source))->size_, offset, byteCount);
  jint limit = offset + byteCount;
  while (offset < limit) {
    OkioSegment *tail = [self writableSegmentWithInt:1];
    jint toCopy = JavaLangMath_minWithInt_withInt_(limit - offset, OkioSegment_SIZE - ((OkioSegment *) nil_chk(tail))->limit_);
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(source, offset, tail->data_, tail->limit_, toCopy);
    offset += toCopy;
    tail->limit_ += toCopy;
  }
  self->size_ += byteCount;
  return self;
}

- (jlong)writeAllWithOkioSource:(id<OkioSource>)source {
  if (source == nil) @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"source == null");
  jlong totalBytesRead = 0;
  for (jlong readCount; (readCount = [((id<OkioSource>) nil_chk(source)) readWithOkioBuffer:self withLong:OkioSegment_SIZE]) != -1; ) {
    totalBytesRead += readCount;
  }
  return totalBytesRead;
}

- (id<OkioBufferedSink>)writeWithOkioSource:(id<OkioSource>)source
                                   withLong:(jlong)byteCount {
  [((id<OkioSource>) nil_chk(source)) readWithOkioBuffer:self withLong:byteCount];
  return self;
}

- (OkioBuffer *)writeByteWithInt:(jint)b {
  OkioSegment *tail = [self writableSegmentWithInt:1];
  *IOSByteArray_GetRef(nil_chk(((OkioSegment *) nil_chk(tail))->data_), tail->limit_++) = (jbyte) b;
  size_ += 1;
  return self;
}

- (OkioBuffer *)writeShortWithInt:(jint)s {
  OkioSegment *tail = [self writableSegmentWithInt:2];
  IOSByteArray *data = ((OkioSegment *) nil_chk(tail))->data_;
  jint limit = tail->limit_;
  *IOSByteArray_GetRef(nil_chk(data), limit++) = (jbyte) ((JreURShift32(s, 8)) & (jint) 0xff);
  *IOSByteArray_GetRef(data, limit++) = (jbyte) (s & (jint) 0xff);
  tail->limit_ = limit;
  size_ += 2;
  return self;
}

- (OkioBuffer *)writeShortLeWithInt:(jint)s {
  return [self writeShortWithInt:OkioUtil_reverseBytesShortWithShort_((jshort) s)];
}

- (OkioBuffer *)writeIntWithInt:(jint)i {
  OkioSegment *tail = [self writableSegmentWithInt:4];
  IOSByteArray *data = ((OkioSegment *) nil_chk(tail))->data_;
  jint limit = tail->limit_;
  *IOSByteArray_GetRef(nil_chk(data), limit++) = (jbyte) ((JreURShift32(i, 24)) & (jint) 0xff);
  *IOSByteArray_GetRef(data, limit++) = (jbyte) ((JreURShift32(i, 16)) & (jint) 0xff);
  *IOSByteArray_GetRef(data, limit++) = (jbyte) ((JreURShift32(i, 8)) & (jint) 0xff);
  *IOSByteArray_GetRef(data, limit++) = (jbyte) (i & (jint) 0xff);
  tail->limit_ = limit;
  size_ += 4;
  return self;
}

- (OkioBuffer *)writeIntLeWithInt:(jint)i {
  return [self writeIntWithInt:OkioUtil_reverseBytesIntWithInt_(i)];
}

- (OkioBuffer *)writeLongWithLong:(jlong)v {
  OkioSegment *tail = [self writableSegmentWithInt:8];
  IOSByteArray *data = ((OkioSegment *) nil_chk(tail))->data_;
  jint limit = tail->limit_;
  *IOSByteArray_GetRef(nil_chk(data), limit++) = (jbyte) ((JreURShift64(v, 56LL)) & (jint) 0xff);
  *IOSByteArray_GetRef(data, limit++) = (jbyte) ((JreURShift64(v, 48LL)) & (jint) 0xff);
  *IOSByteArray_GetRef(data, limit++) = (jbyte) ((JreURShift64(v, 40LL)) & (jint) 0xff);
  *IOSByteArray_GetRef(data, limit++) = (jbyte) ((JreURShift64(v, 32LL)) & (jint) 0xff);
  *IOSByteArray_GetRef(data, limit++) = (jbyte) ((JreURShift64(v, 24LL)) & (jint) 0xff);
  *IOSByteArray_GetRef(data, limit++) = (jbyte) ((JreURShift64(v, 16LL)) & (jint) 0xff);
  *IOSByteArray_GetRef(data, limit++) = (jbyte) ((JreURShift64(v, 8LL)) & (jint) 0xff);
  *IOSByteArray_GetRef(data, limit++) = (jbyte) (v & (jint) 0xff);
  tail->limit_ = limit;
  size_ += 8;
  return self;
}

- (OkioBuffer *)writeLongLeWithLong:(jlong)v {
  return [self writeLongWithLong:OkioUtil_reverseBytesLongWithLong_(v)];
}

- (OkioSegment *)writableSegmentWithInt:(jint)minimumCapacity {
  if (minimumCapacity < 1 || minimumCapacity > OkioSegment_SIZE) @throw new_JavaLangIllegalArgumentException_init();
  if (head_ == nil) {
    head_ = [((OkioSegmentPool *) nil_chk(JreLoadStatic(OkioSegmentPool, INSTANCE))) take];
    return ((OkioSegment *) nil_chk(head_))->next_ = head_->prev_ = head_;
  }
  OkioSegment *tail = ((OkioSegment *) nil_chk(head_))->prev_;
  if (((OkioSegment *) nil_chk(tail))->limit_ + minimumCapacity > OkioSegment_SIZE) {
    tail = [tail pushWithOkioSegment:[((OkioSegmentPool *) nil_chk(JreLoadStatic(OkioSegmentPool, INSTANCE))) take]];
  }
  return tail;
}

- (void)writeWithOkioBuffer:(OkioBuffer *)source
                   withLong:(jlong)byteCount {
  if (source == nil) @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"source == null");
  if (source == self) @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"source == this");
  OkioUtil_checkOffsetAndCountWithLong_withLong_withLong_(((OkioBuffer *) nil_chk(source))->size_, 0, byteCount);
  while (byteCount > 0) {
    if (byteCount < (((OkioSegment *) nil_chk(source->head_))->limit_ - source->head_->pos_)) {
      OkioSegment *tail = head_ != nil ? head_->prev_ : nil;
      if (tail == nil || byteCount + (tail->limit_ - tail->pos_) > OkioSegment_SIZE) {
        source->head_ = [source->head_ splitWithInt:(jint) byteCount];
      }
      else {
        [source->head_ writeToWithOkioSegment:tail withInt:(jint) byteCount];
        source->size_ -= byteCount;
        self->size_ += byteCount;
        return;
      }
    }
    OkioSegment *segmentToMove = source->head_;
    jlong movedByteCount = ((OkioSegment *) nil_chk(segmentToMove))->limit_ - segmentToMove->pos_;
    source->head_ = [segmentToMove pop];
    if (head_ == nil) {
      head_ = segmentToMove;
      head_->next_ = head_->prev_ = head_;
    }
    else {
      OkioSegment *tail = head_->prev_;
      tail = [((OkioSegment *) nil_chk(tail)) pushWithOkioSegment:segmentToMove];
      [((OkioSegment *) nil_chk(tail)) compact];
    }
    source->size_ -= movedByteCount;
    self->size_ += movedByteCount;
    byteCount -= movedByteCount;
  }
}

- (jlong)readWithOkioBuffer:(OkioBuffer *)sink
                   withLong:(jlong)byteCount {
  if (sink == nil) @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"sink == null");
  if (byteCount < 0) @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$J", @"byteCount < 0: ", byteCount));
  if (self->size_ == 0) return -1LL;
  if (byteCount > self->size_) byteCount = self->size_;
  [((OkioBuffer *) nil_chk(sink)) writeWithOkioBuffer:self withLong:byteCount];
  return byteCount;
}

- (jlong)indexOfWithByte:(jbyte)b {
  return [self indexOfWithByte:b withLong:0];
}

- (jlong)indexOfWithByte:(jbyte)b
                withLong:(jlong)fromIndex {
  if (fromIndex < 0) @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"fromIndex < 0");
  OkioSegment *s = head_;
  if (s == nil) return -1LL;
  jlong offset = 0LL;
  do {
    jint segmentByteCount = ((OkioSegment *) nil_chk(s))->limit_ - s->pos_;
    if (fromIndex >= segmentByteCount) {
      fromIndex -= segmentByteCount;
    }
    else {
      IOSByteArray *data = s->data_;
      for (jlong pos = s->pos_ + fromIndex, limit = s->limit_; pos < limit; pos++) {
        if (IOSByteArray_Get(nil_chk(data), (jint) pos) == b) return offset + pos - s->pos_;
      }
      fromIndex = 0;
    }
    offset += segmentByteCount;
    s = s->next_;
  }
  while (s != head_);
  return -1LL;
}

- (jlong)indexOfElementWithOkioByteString:(OkioByteString *)targetBytes {
  return [self indexOfElementWithOkioByteString:targetBytes withLong:0];
}

- (jlong)indexOfElementWithOkioByteString:(OkioByteString *)targetBytes
                                 withLong:(jlong)fromIndex {
  if (fromIndex < 0) @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"fromIndex < 0");
  OkioSegment *s = head_;
  if (s == nil) return -1LL;
  jlong offset = 0LL;
  IOSByteArray *toFind = ((OkioByteString *) nil_chk(targetBytes))->data_;
  do {
    jint segmentByteCount = ((OkioSegment *) nil_chk(s))->limit_ - s->pos_;
    if (fromIndex >= segmentByteCount) {
      fromIndex -= segmentByteCount;
    }
    else {
      IOSByteArray *data = s->data_;
      for (jlong pos = s->pos_ + fromIndex, limit = s->limit_; pos < limit; pos++) {
        jbyte b = IOSByteArray_Get(nil_chk(data), (jint) pos);
        {
          IOSByteArray *a__ = toFind;
          jbyte const *b__ = ((IOSByteArray *) nil_chk(a__))->buffer_;
          jbyte const *e__ = b__ + a__->size_;
          while (b__ < e__) {
            jbyte targetByte = *b__++;
            if (b == targetByte) return offset + pos - s->pos_;
          }
        }
      }
      fromIndex = 0;
    }
    offset += segmentByteCount;
    s = s->next_;
  }
  while (s != head_);
  return -1LL;
}

- (void)flush {
}

- (void)close {
}

- (OkioTimeout *)timeout {
  return JreLoadStatic(OkioTimeout, NONE);
}

- (id<JavaUtilList>)segmentSizes {
  if (head_ == nil) return JavaUtilCollections_emptyList();
  id<JavaUtilList> result = new_JavaUtilArrayList_init();
  [result addWithId:JavaLangInteger_valueOfWithInt_(((OkioSegment *) nil_chk(head_))->limit_ - head_->pos_)];
  for (OkioSegment *s = head_->next_; s != head_; s = s->next_) {
    [result addWithId:JavaLangInteger_valueOfWithInt_(((OkioSegment *) nil_chk(s))->limit_ - s->pos_)];
  }
  return result;
}

- (jboolean)isEqual:(id)o {
  if (self == o) return true;
  if (!([o isKindOfClass:[OkioBuffer class]])) return false;
  OkioBuffer *that = (OkioBuffer *) cast_chk(o, [OkioBuffer class]);
  if (size_ != ((OkioBuffer *) nil_chk(that))->size_) return false;
  if (size_ == 0) return true;
  OkioSegment *sa = self->head_;
  OkioSegment *sb = that->head_;
  jint posA = ((OkioSegment *) nil_chk(sa))->pos_;
  jint posB = ((OkioSegment *) nil_chk(sb))->pos_;
  for (jlong pos = 0, count; pos < size_; pos += count) {
    count = JavaLangMath_minWithInt_withInt_(sa->limit_ - posA, sb->limit_ - posB);
    for (jint i = 0; i < count; i++) {
      if (IOSByteArray_Get(nil_chk(sa->data_), posA++) != IOSByteArray_Get(sb->data_, posB++)) return false;
    }
    if (posA == sa->limit_) {
      sa = sa->next_;
      posA = ((OkioSegment *) nil_chk(sa))->pos_;
    }
    if (posB == sb->limit_) {
      sb = sb->next_;
      posB = ((OkioSegment *) nil_chk(sb))->pos_;
    }
  }
  return true;
}

- (NSUInteger)hash {
  OkioSegment *s = head_;
  if (s == nil) return 0;
  jint result = 1;
  do {
    for (jint pos = ((OkioSegment *) nil_chk(s))->pos_, limit = s->limit_; pos < limit; pos++) {
      result = 31 * result + IOSByteArray_Get(nil_chk(s->data_), pos);
    }
    s = s->next_;
  }
  while (s != head_);
  return result;
}

- (NSString *)description {
  if (size_ == 0) {
    return @"Buffer[size=0]";
  }
  if (size_ <= 16) {
    OkioByteString *data = [((OkioBuffer *) nil_chk([self clone])) readByteString];
    return NSString_formatWithNSString_withNSObjectArray_(@"Buffer[size=%s data=%s]", [IOSObjectArray newArrayWithObjects:(id[]){ JavaLangLong_valueOfWithLong_(size_), [((OkioByteString *) nil_chk(data)) hex] } count:2 type:NSObject_class_()]);
  }
  @try {
    JavaSecurityMessageDigest *md5 = JavaSecurityMessageDigest_getInstanceWithNSString_(@"MD5");
    [((JavaSecurityMessageDigest *) nil_chk(md5)) updateWithByteArray:((OkioSegment *) nil_chk(head_))->data_ withInt:head_->pos_ withInt:head_->limit_ - head_->pos_];
    for (OkioSegment *s = head_->next_; s != head_; s = s->next_) {
      [md5 updateWithByteArray:((OkioSegment *) nil_chk(s))->data_ withInt:s->pos_ withInt:s->limit_ - s->pos_];
    }
    return NSString_formatWithNSString_withNSObjectArray_(@"Buffer[size=%s md5=%s]", [IOSObjectArray newArrayWithObjects:(id[]){ JavaLangLong_valueOfWithLong_(size_), [((OkioByteString *) nil_chk(OkioByteString_ofWithByteArray_([md5 digest]))) hex] } count:2 type:NSObject_class_()]);
  }
  @catch (JavaSecurityNoSuchAlgorithmException *e) {
    @throw new_JavaLangAssertionError_init();
  }
}

- (OkioBuffer *)clone {
  OkioBuffer *result = new_OkioBuffer_init();
  if (size_ == 0) return result;
  (void) [result writeWithByteArray:((OkioSegment *) nil_chk(head_))->data_ withInt:head_->pos_ withInt:head_->limit_ - head_->pos_];
  for (OkioSegment *s = head_->next_; s != head_; s = s->next_) {
    (void) [result writeWithByteArray:((OkioSegment *) nil_chk(s))->data_ withInt:s->pos_ withInt:s->limit_ - s->pos_];
  }
  return result;
}

- (id)copyWithZone:(NSZone *)zone {
  return [self clone];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "Buffer", NULL, 0x1, NULL, NULL },
    { "size", NULL, "J", 0x1, NULL, NULL },
    { "buffer", NULL, "Lokio.Buffer;", 0x1, NULL, NULL },
    { "outputStream", NULL, "Ljava.io.OutputStream;", 0x1, NULL, NULL },
    { "emitCompleteSegments", NULL, "Lokio.Buffer;", 0x1, NULL, NULL },
    { "emit", NULL, "Lokio.BufferedSink;", 0x1, "Ljava.io.IOException;", NULL },
    { "exhausted", NULL, "Z", 0x1, NULL, NULL },
    { "requireWithLong:", "require", "V", 0x1, "Ljava.io.EOFException;", NULL },
    { "requestWithLong:", "request", "Z", 0x1, "Ljava.io.IOException;", NULL },
    { "inputStream", NULL, "Ljava.io.InputStream;", 0x1, NULL, NULL },
    { "copyToWithJavaIoOutputStream:", "copyTo", "Lokio.Buffer;", 0x1, "Ljava.io.IOException;", NULL },
    { "copyToWithJavaIoOutputStream:withLong:withLong:", "copyTo", "Lokio.Buffer;", 0x1, "Ljava.io.IOException;", NULL },
    { "copyToWithOkioBuffer:withLong:withLong:", "copyTo", "Lokio.Buffer;", 0x1, NULL, NULL },
    { "writeToWithJavaIoOutputStream:", "writeTo", "Lokio.Buffer;", 0x1, "Ljava.io.IOException;", NULL },
    { "writeToWithJavaIoOutputStream:withLong:", "writeTo", "Lokio.Buffer;", 0x1, "Ljava.io.IOException;", NULL },
    { "readFromWithJavaIoInputStream:", "readFrom", "Lokio.Buffer;", 0x1, "Ljava.io.IOException;", NULL },
    { "readFromWithJavaIoInputStream:withLong:", "readFrom", "Lokio.Buffer;", 0x1, "Ljava.io.IOException;", NULL },
    { "readFromWithJavaIoInputStream:withLong:withBoolean:", "readFrom", "V", 0x2, "Ljava.io.IOException;", NULL },
    { "completeSegmentByteCount", NULL, "J", 0x1, NULL, NULL },
    { "readByte", NULL, "B", 0x1, NULL, NULL },
    { "getByteWithLong:", "getByte", "B", 0x1, NULL, NULL },
    { "readShort", NULL, "S", 0x1, NULL, NULL },
    { "readInt", NULL, "I", 0x1, NULL, NULL },
    { "readLong", NULL, "J", 0x1, NULL, NULL },
    { "readShortLe", NULL, "S", 0x1, NULL, NULL },
    { "readIntLe", NULL, "I", 0x1, NULL, NULL },
    { "readLongLe", NULL, "J", 0x1, NULL, NULL },
    { "readByteString", NULL, "Lokio.ByteString;", 0x1, NULL, NULL },
    { "readByteStringWithLong:", "readByteString", "Lokio.ByteString;", 0x1, "Ljava.io.EOFException;", NULL },
    { "readFullyWithOkioBuffer:withLong:", "readFully", "V", 0x1, "Ljava.io.EOFException;", NULL },
    { "readAllWithOkioSink:", "readAll", "J", 0x1, "Ljava.io.IOException;", NULL },
    { "readUtf8", NULL, "Ljava.lang.String;", 0x1, NULL, NULL },
    { "readUtf8WithLong:", "readUtf8", "Ljava.lang.String;", 0x1, "Ljava.io.EOFException;", NULL },
    { "readStringWithJavaNioCharsetCharset:", "readString", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "readStringWithLong:withJavaNioCharsetCharset:", "readString", "Ljava.lang.String;", 0x1, "Ljava.io.EOFException;", NULL },
    { "readUtf8Line", NULL, "Ljava.lang.String;", 0x1, "Ljava.io.EOFException;", NULL },
    { "readUtf8LineStrict", NULL, "Ljava.lang.String;", 0x1, "Ljava.io.EOFException;", NULL },
    { "readUtf8LineWithLong:", "readUtf8Line", "Ljava.lang.String;", 0x0, "Ljava.io.EOFException;", NULL },
    { "readByteArray", NULL, "[B", 0x1, NULL, NULL },
    { "readByteArrayWithLong:", "readByteArray", "[B", 0x1, "Ljava.io.EOFException;", NULL },
    { "readWithByteArray:", "read", "I", 0x1, NULL, NULL },
    { "readFullyWithByteArray:", "readFully", "V", 0x1, "Ljava.io.EOFException;", NULL },
    { "readWithByteArray:withInt:withInt:", "read", "I", 0x1, NULL, NULL },
    { "clear", NULL, "V", 0x1, NULL, NULL },
    { "skipWithLong:", "skip", "V", 0x1, "Ljava.io.EOFException;", NULL },
    { "writeWithOkioByteString:", "write", "Lokio.Buffer;", 0x1, NULL, NULL },
    { "writeUtf8WithNSString:", "writeUtf8", "Lokio.Buffer;", 0x1, NULL, NULL },
    { "writeStringWithNSString:withJavaNioCharsetCharset:", "writeString", "Lokio.Buffer;", 0x1, NULL, NULL },
    { "writeWithByteArray:", "write", "Lokio.Buffer;", 0x1, NULL, NULL },
    { "writeWithByteArray:withInt:withInt:", "write", "Lokio.Buffer;", 0x1, NULL, NULL },
    { "writeAllWithOkioSource:", "writeAll", "J", 0x1, "Ljava.io.IOException;", NULL },
    { "writeWithOkioSource:withLong:", "write", "Lokio.BufferedSink;", 0x1, "Ljava.io.IOException;", NULL },
    { "writeByteWithInt:", "writeByte", "Lokio.Buffer;", 0x1, NULL, NULL },
    { "writeShortWithInt:", "writeShort", "Lokio.Buffer;", 0x1, NULL, NULL },
    { "writeShortLeWithInt:", "writeShortLe", "Lokio.Buffer;", 0x1, NULL, NULL },
    { "writeIntWithInt:", "writeInt", "Lokio.Buffer;", 0x1, NULL, NULL },
    { "writeIntLeWithInt:", "writeIntLe", "Lokio.Buffer;", 0x1, NULL, NULL },
    { "writeLongWithLong:", "writeLong", "Lokio.Buffer;", 0x1, NULL, NULL },
    { "writeLongLeWithLong:", "writeLongLe", "Lokio.Buffer;", 0x1, NULL, NULL },
    { "writableSegmentWithInt:", "writableSegment", "Lokio.Segment;", 0x0, NULL, NULL },
    { "writeWithOkioBuffer:withLong:", "write", "V", 0x1, NULL, NULL },
    { "readWithOkioBuffer:withLong:", "read", "J", 0x1, NULL, NULL },
    { "indexOfWithByte:", "indexOf", "J", 0x1, NULL, NULL },
    { "indexOfWithByte:withLong:", "indexOf", "J", 0x1, NULL, NULL },
    { "indexOfElementWithOkioByteString:", "indexOfElement", "J", 0x1, NULL, NULL },
    { "indexOfElementWithOkioByteString:withLong:", "indexOfElement", "J", 0x1, NULL, NULL },
    { "flush", NULL, "V", 0x1, NULL, NULL },
    { "close", NULL, "V", 0x1, NULL, NULL },
    { "timeout", NULL, "Lokio.Timeout;", 0x1, NULL, NULL },
    { "segmentSizes", NULL, "Ljava.util.List;", 0x0, NULL, "()Ljava/util/List<Ljava/lang/Integer;>;" },
    { "isEqual:", "equals", "Z", 0x1, NULL, NULL },
    { "hash", "hashCode", "I", 0x1, NULL, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "clone", NULL, "Lokio.Buffer;", 0x1, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "head_", NULL, 0x0, "Lokio.Segment;", NULL, NULL, .constantValue.asLong = 0 },
    { "size_", NULL, 0x0, "J", NULL, NULL, .constantValue.asLong = 0 },
  };
  static const J2ObjcClassInfo _OkioBuffer = { 2, "Buffer", "okio", NULL, 0x11, 74, methods, 2, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_OkioBuffer;
}

@end

void OkioBuffer_init(OkioBuffer *self) {
  NSObject_init(self);
}

OkioBuffer *new_OkioBuffer_init() {
  OkioBuffer *self = [OkioBuffer alloc];
  OkioBuffer_init(self);
  return self;
}

OkioBuffer *create_OkioBuffer_init() {
  return new_OkioBuffer_init();
}

void OkioBuffer_readFromWithJavaIoInputStream_withLong_withBoolean_(OkioBuffer *self, JavaIoInputStream *inArg, jlong byteCount, jboolean forever) {
  if (inArg == nil) @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"in == null");
  while (byteCount > 0 || forever) {
    OkioSegment *tail = [self writableSegmentWithInt:1];
    jint maxToCopy = (jint) JavaLangMath_minWithLong_withLong_(byteCount, OkioSegment_SIZE - ((OkioSegment *) nil_chk(tail))->limit_);
    jint bytesRead = [((JavaIoInputStream *) nil_chk(inArg)) readWithByteArray:tail->data_ withInt:tail->limit_ withInt:maxToCopy];
    if (bytesRead == -1) {
      if (forever) return;
      @throw new_JavaIoEOFException_init();
    }
    tail->limit_ += bytesRead;
    self->size_ += bytesRead;
    byteCount -= bytesRead;
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OkioBuffer)

@implementation OkioBuffer_$1

- (void)writeWithInt:(jint)b {
  (void) [this$0_ writeByteWithInt:(jbyte) b];
}

- (void)writeWithByteArray:(IOSByteArray *)data
                   withInt:(jint)offset
                   withInt:(jint)byteCount {
  (void) [this$0_ writeWithByteArray:data withInt:offset withInt:byteCount];
}

- (void)flush {
}

- (void)close {
}

- (NSString *)description {
  return JreStrcat("@$", self, @".outputStream()");
}

- (instancetype)initWithOkioBuffer:(OkioBuffer *)outer$ {
  OkioBuffer_$1_initWithOkioBuffer_(self, outer$);
  return self;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "writeWithInt:", "write", "V", 0x1, NULL, NULL },
    { "writeWithByteArray:withInt:withInt:", "write", "V", 0x1, NULL, NULL },
    { "flush", NULL, "V", 0x1, NULL, NULL },
    { "close", NULL, "V", 0x1, NULL, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "initWithOkioBuffer:", "", NULL, 0x0, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", NULL, 0x1012, "Lokio.Buffer;", NULL, NULL, .constantValue.asLong = 0 },
  };
  static const J2ObjCEnclosingMethodInfo enclosing_method = { "OkioBuffer", "outputStream" };
  static const J2ObjcClassInfo _OkioBuffer_$1 = { 2, "", "okio", "Buffer", 0x8008, 6, methods, 1, fields, 0, NULL, 0, NULL, &enclosing_method, NULL };
  return &_OkioBuffer_$1;
}

@end

void OkioBuffer_$1_initWithOkioBuffer_(OkioBuffer_$1 *self, OkioBuffer *outer$) {
  self->this$0_ = outer$;
  JavaIoOutputStream_init(self);
}

OkioBuffer_$1 *new_OkioBuffer_$1_initWithOkioBuffer_(OkioBuffer *outer$) {
  OkioBuffer_$1 *self = [OkioBuffer_$1 alloc];
  OkioBuffer_$1_initWithOkioBuffer_(self, outer$);
  return self;
}

OkioBuffer_$1 *create_OkioBuffer_$1_initWithOkioBuffer_(OkioBuffer *outer$) {
  return new_OkioBuffer_$1_initWithOkioBuffer_(outer$);
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OkioBuffer_$1)

@implementation OkioBuffer_$2

- (jint)read {
  if (this$0_->size_ > 0) return [this$0_ readByte] & (jint) 0xff;
  return -1;
}

- (jint)readWithByteArray:(IOSByteArray *)sink
                  withInt:(jint)offset
                  withInt:(jint)byteCount {
  return [this$0_ readWithByteArray:sink withInt:offset withInt:byteCount];
}

- (jint)available {
  return (jint) JavaLangMath_minWithLong_withLong_(this$0_->size_, JavaLangInteger_MAX_VALUE);
}

- (void)close {
}

- (NSString *)description {
  return JreStrcat("@$", this$0_, @".inputStream()");
}

- (instancetype)initWithOkioBuffer:(OkioBuffer *)outer$ {
  OkioBuffer_$2_initWithOkioBuffer_(self, outer$);
  return self;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "read", NULL, "I", 0x1, NULL, NULL },
    { "readWithByteArray:withInt:withInt:", "read", "I", 0x1, NULL, NULL },
    { "available", NULL, "I", 0x1, NULL, NULL },
    { "close", NULL, "V", 0x1, NULL, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "initWithOkioBuffer:", "", NULL, 0x0, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", NULL, 0x1012, "Lokio.Buffer;", NULL, NULL, .constantValue.asLong = 0 },
  };
  static const J2ObjCEnclosingMethodInfo enclosing_method = { "OkioBuffer", "inputStream" };
  static const J2ObjcClassInfo _OkioBuffer_$2 = { 2, "", "okio", "Buffer", 0x8008, 6, methods, 1, fields, 0, NULL, 0, NULL, &enclosing_method, NULL };
  return &_OkioBuffer_$2;
}

@end

void OkioBuffer_$2_initWithOkioBuffer_(OkioBuffer_$2 *self, OkioBuffer *outer$) {
  self->this$0_ = outer$;
  JavaIoInputStream_init(self);
}

OkioBuffer_$2 *new_OkioBuffer_$2_initWithOkioBuffer_(OkioBuffer *outer$) {
  OkioBuffer_$2 *self = [OkioBuffer_$2 alloc];
  OkioBuffer_$2_initWithOkioBuffer_(self, outer$);
  return self;
}

OkioBuffer_$2 *create_OkioBuffer_$2_initWithOkioBuffer_(OkioBuffer *outer$) {
  return new_OkioBuffer_$2_initWithOkioBuffer_(outer$);
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OkioBuffer_$2)
